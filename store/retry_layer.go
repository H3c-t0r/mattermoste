// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package store

import (
	"context"

	"github.com/go-sql-driver/mysql"
	"github.com/lib/pq"
	"github.com/mattermost/mattermost-server/v5/model"
	"github.com/pkg/errors"
)

type RetryLayer struct {
	Store
	AuditStore                AuditStore
	BotStore                  BotStore
	ChannelStore              ChannelStore
	ChannelMemberHistoryStore ChannelMemberHistoryStore
	ClusterDiscoveryStore     ClusterDiscoveryStore
	CommandStore              CommandStore
	CommandWebhookStore       CommandWebhookStore
	ComplianceStore           ComplianceStore
	EmojiStore                EmojiStore
	FileInfoStore             FileInfoStore
	GroupStore                GroupStore
	JobStore                  JobStore
	LicenseStore              LicenseStore
	LinkMetadataStore         LinkMetadataStore
	OAuthStore                OAuthStore
	PluginStore               PluginStore
	PostStore                 PostStore
	PreferenceStore           PreferenceStore
	ReactionStore             ReactionStore
	RoleStore                 RoleStore
	SchemeStore               SchemeStore
	SessionStore              SessionStore
	StatusStore               StatusStore
	SystemStore               SystemStore
	TeamStore                 TeamStore
	TermsOfServiceStore       TermsOfServiceStore
	TokenStore                TokenStore
	UserStore                 UserStore
	UserAccessTokenStore      UserAccessTokenStore
	UserTermsOfServiceStore   UserTermsOfServiceStore
	WebhookStore              WebhookStore
}

func (s *RetryLayer) Audit() AuditStore {
	return s.AuditStore
}

func (s *RetryLayer) Bot() BotStore {
	return s.BotStore
}

func (s *RetryLayer) Channel() ChannelStore {
	return s.ChannelStore
}

func (s *RetryLayer) ChannelMemberHistory() ChannelMemberHistoryStore {
	return s.ChannelMemberHistoryStore
}

func (s *RetryLayer) ClusterDiscovery() ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *RetryLayer) Command() CommandStore {
	return s.CommandStore
}

func (s *RetryLayer) CommandWebhook() CommandWebhookStore {
	return s.CommandWebhookStore
}

func (s *RetryLayer) Compliance() ComplianceStore {
	return s.ComplianceStore
}

func (s *RetryLayer) Emoji() EmojiStore {
	return s.EmojiStore
}

func (s *RetryLayer) FileInfo() FileInfoStore {
	return s.FileInfoStore
}

func (s *RetryLayer) Group() GroupStore {
	return s.GroupStore
}

func (s *RetryLayer) Job() JobStore {
	return s.JobStore
}

func (s *RetryLayer) License() LicenseStore {
	return s.LicenseStore
}

func (s *RetryLayer) LinkMetadata() LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *RetryLayer) OAuth() OAuthStore {
	return s.OAuthStore
}

func (s *RetryLayer) Plugin() PluginStore {
	return s.PluginStore
}

func (s *RetryLayer) Post() PostStore {
	return s.PostStore
}

func (s *RetryLayer) Preference() PreferenceStore {
	return s.PreferenceStore
}

func (s *RetryLayer) Reaction() ReactionStore {
	return s.ReactionStore
}

func (s *RetryLayer) Role() RoleStore {
	return s.RoleStore
}

func (s *RetryLayer) Scheme() SchemeStore {
	return s.SchemeStore
}

func (s *RetryLayer) Session() SessionStore {
	return s.SessionStore
}

func (s *RetryLayer) Status() StatusStore {
	return s.StatusStore
}

func (s *RetryLayer) System() SystemStore {
	return s.SystemStore
}

func (s *RetryLayer) Team() TeamStore {
	return s.TeamStore
}

func (s *RetryLayer) TermsOfService() TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *RetryLayer) Token() TokenStore {
	return s.TokenStore
}

func (s *RetryLayer) User() UserStore {
	return s.UserStore
}

func (s *RetryLayer) UserAccessToken() UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *RetryLayer) UserTermsOfService() UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *RetryLayer) Webhook() WebhookStore {
	return s.WebhookStore
}

type RetryLayerAuditStore struct {
	AuditStore
	Root *RetryLayer
}

type RetryLayerBotStore struct {
	BotStore
	Root *RetryLayer
}

type RetryLayerChannelStore struct {
	ChannelStore
	Root *RetryLayer
}

type RetryLayerChannelMemberHistoryStore struct {
	ChannelMemberHistoryStore
	Root *RetryLayer
}

type RetryLayerClusterDiscoveryStore struct {
	ClusterDiscoveryStore
	Root *RetryLayer
}

type RetryLayerCommandStore struct {
	CommandStore
	Root *RetryLayer
}

type RetryLayerCommandWebhookStore struct {
	CommandWebhookStore
	Root *RetryLayer
}

type RetryLayerComplianceStore struct {
	ComplianceStore
	Root *RetryLayer
}

type RetryLayerEmojiStore struct {
	EmojiStore
	Root *RetryLayer
}

type RetryLayerFileInfoStore struct {
	FileInfoStore
	Root *RetryLayer
}

type RetryLayerGroupStore struct {
	GroupStore
	Root *RetryLayer
}

type RetryLayerJobStore struct {
	JobStore
	Root *RetryLayer
}

type RetryLayerLicenseStore struct {
	LicenseStore
	Root *RetryLayer
}

type RetryLayerLinkMetadataStore struct {
	LinkMetadataStore
	Root *RetryLayer
}

type RetryLayerOAuthStore struct {
	OAuthStore
	Root *RetryLayer
}

type RetryLayerPluginStore struct {
	PluginStore
	Root *RetryLayer
}

type RetryLayerPostStore struct {
	PostStore
	Root *RetryLayer
}

type RetryLayerPreferenceStore struct {
	PreferenceStore
	Root *RetryLayer
}

type RetryLayerReactionStore struct {
	ReactionStore
	Root *RetryLayer
}

type RetryLayerRoleStore struct {
	RoleStore
	Root *RetryLayer
}

type RetryLayerSchemeStore struct {
	SchemeStore
	Root *RetryLayer
}

type RetryLayerSessionStore struct {
	SessionStore
	Root *RetryLayer
}

type RetryLayerStatusStore struct {
	StatusStore
	Root *RetryLayer
}

type RetryLayerSystemStore struct {
	SystemStore
	Root *RetryLayer
}

type RetryLayerTeamStore struct {
	TeamStore
	Root *RetryLayer
}

type RetryLayerTermsOfServiceStore struct {
	TermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerTokenStore struct {
	TokenStore
	Root *RetryLayer
}

type RetryLayerUserStore struct {
	UserStore
	Root *RetryLayer
}

type RetryLayerUserAccessTokenStore struct {
	UserAccessTokenStore
	Root *RetryLayer
}

type RetryLayerUserTermsOfServiceStore struct {
	UserTermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerWebhookStore struct {
	WebhookStore
	Root *RetryLayer
}

func (s *RetryLayerAuditStore) Get(user_id string, offset int, limit int) (model.Audits, error) {

	resultVar0, resultVar1 := s.AuditStore.Get(user_id, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.AuditStore.Get(user_id, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerAuditStore) PermanentDeleteByUser(userId string) error {

	resultVar0 := s.AuditStore.PermanentDeleteByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.AuditStore.PermanentDeleteByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerAuditStore) Save(audit *model.Audit) error {

	resultVar0 := s.AuditStore.Save(audit)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.AuditStore.Save(audit)
	}

	return resultVar0

}

func (s *RetryLayerBotStore) Get(userId string, includeDeleted bool) (*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.Get(userId, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.BotStore.Get(userId, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerBotStore) GetAll(options *model.BotGetOptions) ([]*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.GetAll(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.BotStore.GetAll(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerBotStore) PermanentDelete(userId string) error {

	resultVar0 := s.BotStore.PermanentDelete(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.BotStore.PermanentDelete(userId)
	}

	return resultVar0

}

func (s *RetryLayerBotStore) Save(bot *model.Bot) (*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.Save(bot)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.BotStore.Save(bot)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerBotStore) Update(bot *model.Bot) (*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.Update(bot)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.BotStore.Update(bot)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AnalyticsDeletedTypeCount(teamId string, channelType string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AnalyticsDeletedTypeCount(teamId, channelType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.AnalyticsDeletedTypeCount(teamId, channelType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AnalyticsTypeCount(teamId string, channelType string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AnalyticsTypeCount(teamId, channelType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.AnalyticsTypeCount(teamId, channelType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AutocompleteInTeam(teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AutocompleteInTeam(teamId, term, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.AutocompleteInTeam(teamId, term, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AutocompleteInTeamForSearch(teamId string, userId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AutocompleteInTeamForSearch(teamId, userId, term, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.AutocompleteInTeamForSearch(teamId, userId, term, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) ClearAllCustomRoleAssignments() *model.AppError {

	resultVar0 := s.ChannelStore.ClearAllCustomRoleAssignments()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.ClearAllCustomRoleAssignments()
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) ClearCaches() {

	s.ChannelStore.ClearCaches()
	return

}

func (s *RetryLayerChannelStore) CountPostsAfter(channelId string, timestamp int64, userId string) (int, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.CountPostsAfter(channelId, timestamp, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.CountPostsAfter(channelId, timestamp, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) CreateDirectChannel(userId *model.User, otherUserId *model.User) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.CreateDirectChannel(userId, otherUserId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.CreateDirectChannel(userId, otherUserId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) Delete(channelId string, time int64) error {

	resultVar0 := s.ChannelStore.Delete(channelId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelStore.Delete(channelId, time)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Get(id string, allowFromCache bool) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.Get(id, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.Get(id, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAll(teamId string) ([]*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAll(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetAll(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelMembersForUser(userId string, allowFromCache bool, includeDeleted bool) (map[string]string, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelMembersForUser(userId, allowFromCache, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelMembersForUser(userId, allowFromCache, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelMembersNotifyPropsForChannel(channelId string, allowFromCache bool) (map[string]model.StringMap, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannels(page int, perPage int, opts ChannelSearchOpts) (*model.ChannelListWithTeamData, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannels(page, perPage, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetAllChannels(page, perPage, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelsCount(opts ChannelSearchOpts) (int64, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelsCount(opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelsCount(opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelsForExportAfter(limit int, afterId string) ([]*model.ChannelForExport, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelsForExportAfter(limit, afterId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelsForExportAfter(limit, afterId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllDirectChannelsForExportAfter(limit int, afterId string) ([]*model.DirectChannelForExport, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetByName(team_id string, name string, allowFromCache bool) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetByName(team_id, name, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetByName(team_id, name, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetByNameIncludeDeleted(team_id string, name string, allowFromCache bool) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetByNameIncludeDeleted(team_id, name, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetByNameIncludeDeleted(team_id, name, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetByNames(team_id string, names []string, allowFromCache bool) ([]*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetByNames(team_id, names, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetByNames(team_id, names, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelCounts(teamId string, userId string) (*model.ChannelCounts, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelCounts(teamId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelCounts(teamId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelMembersForExport(userId string, teamId string) ([]*model.ChannelMemberForExport, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelMembersForExport(userId, teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelMembersForExport(userId, teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelMembersTimezones(channelId string) ([]model.StringMap, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelMembersTimezones(channelId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelMembersTimezones(channelId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelUnread(channelId string, userId string) (*model.ChannelUnread, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelUnread(channelId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelUnread(channelId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannels(teamId string, userId string, includeDeleted bool) (*model.ChannelList, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannels(teamId, userId, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetChannels(teamId, userId, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelsBatchForIndexing(startTime, endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelsBatchForIndexing(startTime, endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelsByIds(channelIds []string, includeDeleted bool) ([]*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelsByScheme(schemeId string, offset int, limit int) (model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelsByScheme(schemeId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetChannelsByScheme(schemeId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetDeleted(team_id string, offset int, limit int, userId string) (*model.ChannelList, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetDeleted(team_id, offset, limit, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetDeleted(team_id, offset, limit, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetDeletedByName(team_id string, name string) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetDeletedByName(team_id, name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetDeletedByName(team_id, name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetForPost(postId string) (*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetForPost(postId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetForPost(postId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetFromMaster(id string) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetFromMaster(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetFromMaster(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetGuestCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetGuestCount(channelId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetGuestCount(channelId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMember(channelId string, userId string) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMember(channelId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMember(channelId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMemberCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMemberCount(channelId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMemberCount(channelId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMemberCountFromCache(channelId string) int64 {

	resultVar0 := s.ChannelStore.GetMemberCountFromCache(channelId)

	return resultVar0

}

func (s *RetryLayerChannelStore) GetMemberCountsByGroup(channelID string, includeTimezones bool) ([]*model.ChannelMemberCountByGroup, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMemberCountsByGroup(channelID, includeTimezones)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMemberCountsByGroup(channelID, includeTimezones)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMemberForPost(postId string, userId string) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMemberForPost(postId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMemberForPost(postId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembers(channelId string, offset int, limit int) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembers(channelId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMembers(channelId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembersByIds(channelId string, userIds []string) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembersByIds(channelId, userIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMembersByIds(channelId, userIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembersForUser(teamId string, userId string) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembersForUser(teamId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMembersForUser(teamId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembersForUserWithPagination(teamId string, userId string, page int, perPage int) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembersForUserWithPagination(teamId, userId, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetMembersForUserWithPagination(teamId, userId, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMoreChannels(teamId string, userId string, offset int, limit int) (*model.ChannelList, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetMoreChannels(teamId, userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.GetMoreChannels(teamId, userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPinnedPostCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPinnedPostCount(channelId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetPinnedPostCount(channelId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPinnedPosts(channelId string) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPinnedPosts(channelId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetPinnedPosts(channelId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPublicChannelsByIdsForTeam(teamId string, channelIds []string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPublicChannelsByIdsForTeam(teamId, channelIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetPublicChannelsByIdsForTeam(teamId, channelIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPublicChannelsForTeam(teamId string, offset int, limit int) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPublicChannelsForTeam(teamId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetPublicChannelsForTeam(teamId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetTeamChannels(teamId string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetTeamChannels(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GetTeamChannels(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GroupSyncedChannelCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GroupSyncedChannelCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.GroupSyncedChannelCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) IncrementMentionCount(channelId string, userId string) *model.AppError {

	resultVar0 := s.ChannelStore.IncrementMentionCount(channelId, userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.IncrementMentionCount(channelId, userId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) InvalidateAllChannelMembersForUser(userId string) {

	s.ChannelStore.InvalidateAllChannelMembersForUser(userId)
	return

}

func (s *RetryLayerChannelStore) InvalidateCacheForChannelMembersNotifyProps(channelId string) {

	s.ChannelStore.InvalidateCacheForChannelMembersNotifyProps(channelId)
	return

}

func (s *RetryLayerChannelStore) InvalidateChannel(id string) {

	s.ChannelStore.InvalidateChannel(id)
	return

}

func (s *RetryLayerChannelStore) InvalidateChannelByName(teamId string, name string) {

	s.ChannelStore.InvalidateChannelByName(teamId, name)
	return

}

func (s *RetryLayerChannelStore) InvalidateGuestCount(channelId string) {

	s.ChannelStore.InvalidateGuestCount(channelId)
	return

}

func (s *RetryLayerChannelStore) InvalidateMemberCount(channelId string) {

	s.ChannelStore.InvalidateMemberCount(channelId)
	return

}

func (s *RetryLayerChannelStore) InvalidatePinnedPostCount(channelId string) {

	s.ChannelStore.InvalidatePinnedPostCount(channelId)
	return

}

func (s *RetryLayerChannelStore) IsUserInChannelUseCache(userId string, channelId string) bool {

	resultVar0 := s.ChannelStore.IsUserInChannelUseCache(userId, channelId)

	return resultVar0

}

func (s *RetryLayerChannelStore) MigrateChannelMembers(fromChannelId string, fromUserId string) (map[string]string, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.MigrateChannelMembers(fromChannelId, fromUserId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.MigrateChannelMembers(fromChannelId, fromUserId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) MigratePublicChannels() error {

	resultVar0 := s.ChannelStore.MigratePublicChannels()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelStore.MigratePublicChannels()
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDelete(channelId string) error {

	resultVar0 := s.ChannelStore.PermanentDelete(channelId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelStore.PermanentDelete(channelId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDeleteByTeam(teamId string) error {

	resultVar0 := s.ChannelStore.PermanentDeleteByTeam(teamId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelStore.PermanentDeleteByTeam(teamId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDeleteMembersByChannel(channelId string) *model.AppError {

	resultVar0 := s.ChannelStore.PermanentDeleteMembersByChannel(channelId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.PermanentDeleteMembersByChannel(channelId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDeleteMembersByUser(userId string) *model.AppError {

	resultVar0 := s.ChannelStore.PermanentDeleteMembersByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.PermanentDeleteMembersByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) RemoveAllDeactivatedMembers(channelId string) *model.AppError {

	resultVar0 := s.ChannelStore.RemoveAllDeactivatedMembers(channelId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.RemoveAllDeactivatedMembers(channelId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) RemoveMember(channelId string, userId string) *model.AppError {

	resultVar0 := s.ChannelStore.RemoveMember(channelId, userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.RemoveMember(channelId, userId)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) RemoveMembers(channelId string, userIds []string) *model.AppError {

	resultVar0 := s.ChannelStore.RemoveMembers(channelId, userIds)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.RemoveMembers(channelId, userIds)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) ResetAllChannelSchemes() *model.AppError {

	resultVar0 := s.ChannelStore.ResetAllChannelSchemes()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.ResetAllChannelSchemes()
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Restore(channelId string, time int64) error {

	resultVar0 := s.ChannelStore.Restore(channelId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelStore.Restore(channelId, time)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Save(channel *model.Channel, maxChannelsPerTeam int64) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.Save(channel, maxChannelsPerTeam)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.Save(channel, maxChannelsPerTeam)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SaveDirectChannel(channel *model.Channel, member1 *model.ChannelMember, member2 *model.ChannelMember) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.SaveDirectChannel(channel, member1, member2)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.SaveDirectChannel(channel, member1, member2)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SaveMember(member *model.ChannelMember) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SaveMember(member)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SaveMember(member)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SaveMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SaveMultipleMembers(members)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SaveMultipleMembers(members)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchAllChannels(term string, opts ChannelSearchOpts) (*model.ChannelListWithTeamData, int64, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.ChannelStore.SearchAllChannels(term, opts)

	tries := 0
	for {
		tries++
		if resultVar2 == nil {
			break
		}

		break

		resultVar0, resultVar1, resultVar2 = s.ChannelStore.SearchAllChannels(term, opts)
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerChannelStore) SearchArchivedInTeam(teamId string, term string, userId string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchArchivedInTeam(teamId, term, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SearchArchivedInTeam(teamId, term, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchForUserInTeam(userId string, teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchForUserInTeam(userId, teamId, term, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SearchForUserInTeam(userId, teamId, term, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchGroupChannels(userId string, term string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchGroupChannels(userId, term)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SearchGroupChannels(userId, term)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchInTeam(teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchInTeam(teamId, term, includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SearchInTeam(teamId, term, includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchMore(userId string, teamId string, term string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchMore(userId, teamId, term)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.SearchMore(userId, teamId, term)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SetDeleteAt(channelId string, deleteAt int64, updateAt int64) error {

	resultVar0 := s.ChannelStore.SetDeleteAt(channelId, deleteAt, updateAt)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelStore.SetDeleteAt(channelId, deleteAt, updateAt)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Update(channel *model.Channel) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.Update(channel)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelStore.Update(channel)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateLastViewedAt(channelIds []string, userId string) (map[string]int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateLastViewedAt(channelIds, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.UpdateLastViewedAt(channelIds, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateLastViewedAtPost(unreadPost *model.Post, userID string, mentionCount int) (*model.ChannelUnreadAt, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateMember(member *model.ChannelMember) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateMember(member)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.UpdateMember(member)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateMembersRole(channelID string, userIDs []string) *model.AppError {

	resultVar0 := s.ChannelStore.UpdateMembersRole(channelID, userIDs)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ChannelStore.UpdateMembersRole(channelID, userIDs)
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) UpdateMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateMultipleMembers(members)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.UpdateMultipleMembers(members)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UserBelongsToChannels(userId string, channelIds []string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UserBelongsToChannels(userId, channelIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ChannelStore.UserBelongsToChannels(userId, channelIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelMemberHistoryStore) GetUsersInChannelDuring(startTime int64, endTime int64, channelId string) ([]*model.ChannelMemberHistoryResult, error) {

	resultVar0, resultVar1 := s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelMemberHistoryStore) LogJoinEvent(userId string, channelId string, joinTime int64) error {

	resultVar0 := s.ChannelMemberHistoryStore.LogJoinEvent(userId, channelId, joinTime)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelMemberHistoryStore.LogJoinEvent(userId, channelId, joinTime)
	}

	return resultVar0

}

func (s *RetryLayerChannelMemberHistoryStore) LogLeaveEvent(userId string, channelId string, leaveTime int64) error {

	resultVar0 := s.ChannelMemberHistoryStore.LogLeaveEvent(userId, channelId, leaveTime)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.ChannelMemberHistoryStore.LogLeaveEvent(userId, channelId, leaveTime)
	}

	return resultVar0

}

func (s *RetryLayerChannelMemberHistoryStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {

	resultVar0, resultVar1 := s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) Cleanup() *model.AppError {

	resultVar0 := s.ClusterDiscoveryStore.Cleanup()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ClusterDiscoveryStore.Cleanup()
	}

	return resultVar0

}

func (s *RetryLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.Delete(discovery)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ClusterDiscoveryStore.Delete(discovery)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.Exists(discovery)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ClusterDiscoveryStore.Exists(discovery)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, *model.AppError) {

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) *model.AppError {

	resultVar0 := s.ClusterDiscoveryStore.Save(discovery)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ClusterDiscoveryStore.Save(discovery)
	}

	return resultVar0

}

func (s *RetryLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) *model.AppError {

	resultVar0 := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ClusterDiscoveryStore.SetLastPingAt(discovery)
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) AnalyticsCommandCount(teamId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.AnalyticsCommandCount(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandStore.AnalyticsCommandCount(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) Delete(commandId string, time int64) *model.AppError {

	resultVar0 := s.CommandStore.Delete(commandId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.CommandStore.Delete(commandId, time)
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) Get(id string) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) GetByTeam(teamId string) ([]*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.GetByTeam(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandStore.GetByTeam(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) GetByTrigger(teamId string, trigger string) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.GetByTrigger(teamId, trigger)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandStore.GetByTrigger(teamId, trigger)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) PermanentDeleteByTeam(teamId string) *model.AppError {

	resultVar0 := s.CommandStore.PermanentDeleteByTeam(teamId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.CommandStore.PermanentDeleteByTeam(teamId)
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.CommandStore.PermanentDeleteByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.CommandStore.PermanentDeleteByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) Save(webhook *model.Command) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.Save(webhook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandStore.Save(webhook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) Update(hook *model.Command) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.Update(hook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandStore.Update(hook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandWebhookStore) Cleanup() {

	s.CommandWebhookStore.Cleanup()
	return

}

func (s *RetryLayerCommandWebhookStore) Get(id string) (*model.CommandWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.CommandWebhookStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandWebhookStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandWebhookStore) Save(webhook *model.CommandWebhook) (*model.CommandWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.CommandWebhookStore.Save(webhook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.CommandWebhookStore.Save(webhook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandWebhookStore) TryUse(id string, limit int) *model.AppError {

	resultVar0 := s.CommandWebhookStore.TryUse(id, limit)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.CommandWebhookStore.TryUse(id, limit)
	}

	return resultVar0

}

func (s *RetryLayerComplianceStore) ComplianceExport(compliance *model.Compliance) ([]*model.CompliancePost, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.ComplianceExport(compliance)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ComplianceStore.ComplianceExport(compliance)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) Get(id string) (*model.Compliance, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ComplianceStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.GetAll(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ComplianceStore.GetAll(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) MessageExport(after int64, limit int) ([]*model.MessageExport, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.MessageExport(after, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ComplianceStore.MessageExport(after, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.Save(compliance)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ComplianceStore.Save(compliance)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.Update(compliance)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ComplianceStore.Update(compliance)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) Delete(emoji *model.Emoji, time int64) error {

	resultVar0 := s.EmojiStore.Delete(emoji, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.EmojiStore.Delete(emoji, time)
	}

	return resultVar0

}

func (s *RetryLayerEmojiStore) Get(id string, allowFromCache bool) (*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.Get(id, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.EmojiStore.Get(id, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) GetByName(name string, allowFromCache bool) (*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.GetByName(name, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.EmojiStore.GetByName(name, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) GetList(offset int, limit int, sort string) ([]*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.GetList(offset, limit, sort)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.EmojiStore.GetList(offset, limit, sort)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) GetMultipleByName(names []string) ([]*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.GetMultipleByName(names)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.EmojiStore.GetMultipleByName(names)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) Save(emoji *model.Emoji) (*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.Save(emoji)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.EmojiStore.Save(emoji)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) Search(name string, prefixOnly bool, limit int) ([]*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.Search(name, prefixOnly, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.EmojiStore.Search(name, prefixOnly, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) AttachToPost(fileId string, postId string, creatorId string) *model.AppError {

	resultVar0 := s.FileInfoStore.AttachToPost(fileId, postId, creatorId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.FileInfoStore.AttachToPost(fileId, postId, creatorId)
	}

	return resultVar0

}

func (s *RetryLayerFileInfoStore) ClearCaches() {

	s.FileInfoStore.ClearCaches()
	return

}

func (s *RetryLayerFileInfoStore) DeleteForPost(postId string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.DeleteForPost(postId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.DeleteForPost(postId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) Get(id string) (*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetByPath(path)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.GetByPath(path)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetForPost(postId string, readFromMaster bool, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetForPost(postId, readFromMaster, includeDeleted, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.GetForPost(postId, readFromMaster, includeDeleted, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetForUser(userId string) ([]*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetForUser(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.GetForUser(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.GetWithOptions(page, perPage, opt)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) InvalidateFileInfosForPostCache(postId string, deleted bool) {

	s.FileInfoStore.InvalidateFileInfosForPostCache(postId, deleted)
	return

}

func (s *RetryLayerFileInfoStore) PermanentDelete(fileId string) *model.AppError {

	resultVar0 := s.FileInfoStore.PermanentDelete(fileId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.FileInfoStore.PermanentDelete(fileId)
	}

	return resultVar0

}

func (s *RetryLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.PermanentDeleteBatch(endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) PermanentDeleteByUser(userId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.PermanentDeleteByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.PermanentDeleteByUser(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) Save(info *model.FileInfo) (*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.Save(info)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.FileInfoStore.Save(info)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) AdminRoleGroupsForSyncableMember(userID string, syncableID string, syncableType model.GroupSyncableType) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) ChannelMembersMinusGroupMembers(channelID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) ChannelMembersToAdd(since int64, channelID *string) ([]*model.UserChannelIDPair, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.ChannelMembersToAdd(since, channelID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.ChannelMembersToAdd(since, channelID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) ChannelMembersToRemove(channelID *string) ([]*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.ChannelMembersToRemove(channelID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.ChannelMembersToRemove(channelID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountChannelMembersMinusGroupMembers(channelID string, groupIDs []string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountGroupsByChannel(channelId string, opts model.GroupSearchOpts) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountGroupsByChannel(channelId, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.CountGroupsByChannel(channelId, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountGroupsByTeam(teamId string, opts model.GroupSearchOpts) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountGroupsByTeam(teamId, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.CountGroupsByTeam(teamId, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountTeamMembersMinusGroupMembers(teamID string, groupIDs []string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Create(group *model.Group) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Create(group)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.Create(group)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CreateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CreateGroupSyncable(groupSyncable)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.CreateGroupSyncable(groupSyncable)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Delete(groupID string) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Delete(groupID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.Delete(groupID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) DeleteGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) DeleteMember(groupID string, userID string) (*model.GroupMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.DeleteMember(groupID, userID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.DeleteMember(groupID, userID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) DistinctGroupMemberCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.DistinctGroupMemberCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.DistinctGroupMemberCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Get(groupID string) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Get(groupID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.Get(groupID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetAllBySource(groupSource model.GroupSource) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetAllBySource(groupSource)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetAllBySource(groupSource)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetAllGroupSyncablesByGroupId(groupID string, syncableType model.GroupSyncableType) ([]*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByIDs(groupIDs []string) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByIDs(groupIDs)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetByIDs(groupIDs)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByName(name string, opts model.GroupSearchOpts) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByName(name, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetByName(name, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByRemoteID(remoteID string, groupSource model.GroupSource) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByRemoteID(remoteID, groupSource)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetByRemoteID(remoteID, groupSource)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByUser(userId string) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetByUser(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroups(page int, perPage int, opts model.GroupSearchOpts) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroups(page, perPage, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetGroups(page, perPage, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupsAssociatedToChannelsByTeam(teamId string, opts model.GroupSearchOpts) (map[string][]*model.GroupWithSchemeAdmin, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamId, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamId, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupsByChannel(channelId string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupsByChannel(channelId, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetGroupsByChannel(channelId, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupsByTeam(teamId string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupsByTeam(teamId, opts)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetGroupsByTeam(teamId, opts)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberCount(groupID string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberCount(groupID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetMemberCount(groupID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsers(groupID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsers(groupID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetMemberUsers(groupID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsersInTeam(groupID string, teamID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsersInTeam(groupID, teamID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetMemberUsersInTeam(groupID, teamID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsersNotInChannel(groupID string, channelID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsersPage(groupID string, page int, perPage int) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsersPage(groupID, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GetMemberUsersPage(groupID, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupChannelCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupChannelCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GroupChannelCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GroupCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupCountWithAllowReference() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupCountWithAllowReference()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GroupCountWithAllowReference()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupMemberCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupMemberCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GroupMemberCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupTeamCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.GroupTeamCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) PermanentDeleteMembersByUser(userId string) *model.AppError {

	resultVar0 := s.GroupStore.PermanentDeleteMembersByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.GroupStore.PermanentDeleteMembersByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerGroupStore) PermittedSyncableAdmins(syncableID string, syncableType model.GroupSyncableType) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) TeamMembersMinusGroupMembers(teamID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) TeamMembersToAdd(since int64, teamID *string) ([]*model.UserTeamIDPair, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.TeamMembersToAdd(since, teamID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.TeamMembersToAdd(since, teamID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) TeamMembersToRemove(teamID *string) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.TeamMembersToRemove(teamID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.TeamMembersToRemove(teamID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Update(group *model.Group) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Update(group)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.Update(group)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) UpdateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.UpdateGroupSyncable(groupSyncable)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.UpdateGroupSyncable(groupSyncable)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) UpsertMember(groupID string, userID string) (*model.GroupMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.UpsertMember(groupID, userID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.GroupStore.UpsertMember(groupID, userID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) Delete(id string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.Delete(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.Delete(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) Get(id string) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllByStatus(status string) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllByStatus(status)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.GetAllByStatus(status)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllByType(jobType string) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllByType(jobType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.GetAllByType(jobType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.GetAllByTypePage(jobType, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllPage(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.GetAllPage(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetCountByStatusAndType(status, jobType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.GetCountByStatusAndType(status, jobType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.GetNewestJobByStatusAndType(status, jobType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) Save(job *model.Job) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.Save(job)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.Save(job)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.UpdateOptimistically(job, currentStatus)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.UpdateOptimistically(job, currentStatus)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) UpdateStatus(id string, status string) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.UpdateStatus(id, status)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.UpdateStatus(id, status)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLicenseStore) Get(id string) (*model.LicenseRecord, error) {

	resultVar0, resultVar1 := s.LicenseStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.LicenseStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLicenseStore) Save(license *model.LicenseRecord) (*model.LicenseRecord, error) {

	resultVar0, resultVar1 := s.LicenseStore.Save(license)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.LicenseStore.Save(license)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, error) {

	resultVar0, resultVar1 := s.LinkMetadataStore.Get(url, timestamp)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.LinkMetadataStore.Get(url, timestamp)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, error) {

	resultVar0, resultVar1 := s.LinkMetadataStore.Save(linkMetadata)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.LinkMetadataStore.Save(linkMetadata)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) DeleteApp(id string) *model.AppError {

	resultVar0 := s.OAuthStore.DeleteApp(id)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.OAuthStore.DeleteApp(id)
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) GetAccessData(token string) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAccessData(token)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetAccessData(token)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAccessDataByRefreshToken(token)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetAccessDataByRefreshToken(token)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAccessDataByUserForApp(userId string, clientId string) ([]*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetApp(id string) (*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetApp(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetApp(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAppByUser(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAppByUser(userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetAppByUser(userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetApps(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetApps(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAuthData(code string) (*model.AuthData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAuthData(code)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetAuthData(code)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAuthorizedApps(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAuthorizedApps(userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetAuthorizedApps(userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetPreviousAccessData(userId string, clientId string) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetPreviousAccessData(userId, clientId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.GetPreviousAccessData(userId, clientId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) PermanentDeleteAuthDataByUser(userId string) *model.AppError {

	resultVar0 := s.OAuthStore.PermanentDeleteAuthDataByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.OAuthStore.PermanentDeleteAuthDataByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) RemoveAccessData(token string) *model.AppError {

	resultVar0 := s.OAuthStore.RemoveAccessData(token)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.OAuthStore.RemoveAccessData(token)
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) RemoveAllAccessData() *model.AppError {

	resultVar0 := s.OAuthStore.RemoveAllAccessData()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.OAuthStore.RemoveAllAccessData()
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) RemoveAuthData(code string) *model.AppError {

	resultVar0 := s.OAuthStore.RemoveAuthData(code)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.OAuthStore.RemoveAuthData(code)
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.SaveAccessData(accessData)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.SaveAccessData(accessData)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.SaveApp(app)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.SaveApp(app)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.SaveAuthData(authData)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.SaveAuthData(authData)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.UpdateAccessData(accessData)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.UpdateAccessData(accessData)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.UpdateApp(app)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.OAuthStore.UpdateApp(app)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PluginStore.CompareAndDelete(keyVal, oldValue)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.CompareAndSet(keyVal, oldValue)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PluginStore.CompareAndSet(keyVal, oldValue)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) Delete(pluginId string, key string) *model.AppError {

	resultVar0 := s.PluginStore.Delete(pluginId, key)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PluginStore.Delete(pluginId, key)
	}

	return resultVar0

}

func (s *RetryLayerPluginStore) DeleteAllExpired() *model.AppError {

	resultVar0 := s.PluginStore.DeleteAllExpired()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PluginStore.DeleteAllExpired()
	}

	return resultVar0

}

func (s *RetryLayerPluginStore) DeleteAllForPlugin(PluginId string) *model.AppError {

	resultVar0 := s.PluginStore.DeleteAllForPlugin(PluginId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PluginStore.DeleteAllForPlugin(PluginId)
	}

	return resultVar0

}

func (s *RetryLayerPluginStore) Get(pluginId string, key string) (*model.PluginKeyValue, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.Get(pluginId, key)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PluginStore.Get(pluginId, key)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) List(pluginId string, page int, perPage int) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.List(pluginId, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PluginStore.List(pluginId, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.SaveOrUpdate(keyVal)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PluginStore.SaveOrUpdate(keyVal)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) SetWithOptions(pluginId string, key string, value []byte, options model.PluginKVSetOptions) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.SetWithOptions(pluginId, key, value, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PluginStore.SetWithOptions(pluginId, key, value, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) AnalyticsPostCount(teamId string, mustHaveFile bool, mustHaveHashtag bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.AnalyticsPostCount(teamId, mustHaveFile, mustHaveHashtag)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.AnalyticsPostCount(teamId, mustHaveFile, mustHaveHashtag)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) AnalyticsPostCountsByDay(options *model.AnalyticsPostCountsOptions) (model.AnalyticsRows, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.AnalyticsPostCountsByDay(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.AnalyticsPostCountsByDay(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) AnalyticsUserCountsWithPostsByDay(teamId string) (model.AnalyticsRows, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.AnalyticsUserCountsWithPostsByDay(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.AnalyticsUserCountsWithPostsByDay(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) ClearCaches() {

	s.PostStore.ClearCaches()
	return

}

func (s *RetryLayerPostStore) Delete(postId string, time int64, deleteByID string) *model.AppError {

	resultVar0 := s.PostStore.Delete(postId, time, deleteByID)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PostStore.Delete(postId, time, deleteByID)
	}

	return resultVar0

}

func (s *RetryLayerPostStore) Get(id string, skipFetchThreads bool) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Get(id, skipFetchThreads)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.Get(id, skipFetchThreads)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetDirectPostParentsForExportAfter(limit int, afterId string) ([]*model.DirectPostForExport, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetDirectPostParentsForExportAfter(limit, afterId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetDirectPostParentsForExportAfter(limit, afterId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetEtag(channelId string, allowFromCache bool) string {

	resultVar0 := s.PostStore.GetEtag(channelId, allowFromCache)

	return resultVar0

}

func (s *RetryLayerPostStore) GetFlaggedPosts(userId string, offset int, limit int) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPosts(userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetFlaggedPosts(userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetFlaggedPostsForChannel(userId string, channelId string, offset int, limit int) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPostsForChannel(userId, channelId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetFlaggedPostsForChannel(userId, channelId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetFlaggedPostsForTeam(userId string, teamId string, offset int, limit int) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPostsForTeam(userId, teamId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetFlaggedPostsForTeam(userId, teamId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetMaxPostSize() int {

	resultVar0 := s.PostStore.GetMaxPostSize()

	return resultVar0

}

func (s *RetryLayerPostStore) GetOldest() (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetOldest()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetOldest()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetOldestEntityCreationTime() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetOldestEntityCreationTime()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetOldestEntityCreationTime()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetParentsForExportAfter(limit int, afterId string) ([]*model.PostForExport, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetParentsForExportAfter(limit, afterId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetParentsForExportAfter(limit, afterId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostAfterTime(channelId string, time int64) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostAfterTime(channelId, time)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostAfterTime(channelId, time)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostIdAfterTime(channelId string, time int64) (string, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostIdAfterTime(channelId, time)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostIdAfterTime(channelId, time)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostIdBeforeTime(channelId string, time int64) (string, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostIdBeforeTime(channelId, time)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostIdBeforeTime(channelId, time)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPosts(options model.GetPostsOptions, allowFromCache bool) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPosts(options, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPosts(options, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsAfter(options model.GetPostsOptions) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsAfter(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostsAfter(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.PostForIndexing, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsBatchForIndexing(startTime, endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostsBatchForIndexing(startTime, endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsBefore(options model.GetPostsOptions) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsBefore(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostsBefore(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsByIds(postIds []string) ([]*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsByIds(postIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostsByIds(postIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsCreatedAt(channelId string, time int64) ([]*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsCreatedAt(channelId, time)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostsCreatedAt(channelId, time)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsSince(options model.GetPostsSinceOptions, allowFromCache bool) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsSince(options, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetPostsSince(options, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetRepliesForExport(parentId string) ([]*model.ReplyForExport, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetRepliesForExport(parentId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetRepliesForExport(parentId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetSingle(id string) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetSingle(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.GetSingle(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) InvalidateLastPostTimeCache(channelId string) {

	s.PostStore.InvalidateLastPostTimeCache(channelId)
	return

}

func (s *RetryLayerPostStore) Overwrite(post *model.Post) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Overwrite(post)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.Overwrite(post)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) OverwriteMultiple(posts []*model.Post) ([]*model.Post, int, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.PostStore.OverwriteMultiple(posts)

	tries := 0
	for {
		tries++
		if resultVar2 == nil {
			break
		}

		break

		resultVar0, resultVar1, resultVar2 = s.PostStore.OverwriteMultiple(posts)
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerPostStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.PermanentDeleteBatch(endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.PermanentDeleteBatch(endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) PermanentDeleteByChannel(channelId string) *model.AppError {

	resultVar0 := s.PostStore.PermanentDeleteByChannel(channelId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PostStore.PermanentDeleteByChannel(channelId)
	}

	return resultVar0

}

func (s *RetryLayerPostStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.PostStore.PermanentDeleteByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PostStore.PermanentDeleteByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerPostStore) Save(post *model.Post) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Save(post)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.Save(post)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) SaveMultiple(posts []*model.Post) ([]*model.Post, int, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.PostStore.SaveMultiple(posts)

	tries := 0
	for {
		tries++
		if resultVar2 == nil {
			break
		}

		break

		resultVar0, resultVar1, resultVar2 = s.PostStore.SaveMultiple(posts)
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerPostStore) Search(teamId string, userId string, params *model.SearchParams) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Search(teamId, userId, params)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.Search(teamId, userId, params)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) SearchPostsInTeamForUser(paramsList []*model.SearchParams, userId string, teamId string, isOrSearch bool, includeDeletedChannels bool, page int, perPage int) (*model.PostSearchResults, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.SearchPostsInTeamForUser(paramsList, userId, teamId, isOrSearch, includeDeletedChannels, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.SearchPostsInTeamForUser(paramsList, userId, teamId, isOrSearch, includeDeletedChannels, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) Update(newPost *model.Post, oldPost *model.Post) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Update(newPost, oldPost)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PostStore.Update(newPost, oldPost)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.CleanupFlagsBatch(limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PreferenceStore.CleanupFlagsBatch(limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) Delete(userId string, category string, name string) *model.AppError {

	resultVar0 := s.PreferenceStore.Delete(userId, category, name)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PreferenceStore.Delete(userId, category, name)
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) DeleteCategory(userId string, category string) *model.AppError {

	resultVar0 := s.PreferenceStore.DeleteCategory(userId, category)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PreferenceStore.DeleteCategory(userId, category)
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) DeleteCategoryAndName(category string, name string) *model.AppError {

	resultVar0 := s.PreferenceStore.DeleteCategoryAndName(category, name)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PreferenceStore.DeleteCategoryAndName(category, name)
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) Get(userId string, category string, name string) (*model.Preference, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.Get(userId, category, name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PreferenceStore.Get(userId, category, name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) GetAll(userId string) (model.Preferences, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.GetAll(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PreferenceStore.GetAll(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) GetCategory(userId string, category string) (model.Preferences, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.GetCategory(userId, category)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.PreferenceStore.GetCategory(userId, category)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.PreferenceStore.PermanentDeleteByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PreferenceStore.PermanentDeleteByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) Save(preferences *model.Preferences) *model.AppError {

	resultVar0 := s.PreferenceStore.Save(preferences)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.PreferenceStore.Save(preferences)
	}

	return resultVar0

}

func (s *RetryLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.BulkGetForPosts(postIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ReactionStore.BulkGetForPosts(postIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.Delete(reaction)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ReactionStore.Delete(reaction)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) DeleteAllWithEmojiName(emojiName string) *model.AppError {

	resultVar0 := s.ReactionStore.DeleteAllWithEmojiName(emojiName)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.ReactionStore.DeleteAllWithEmojiName(emojiName)
	}

	return resultVar0

}

func (s *RetryLayerReactionStore) GetForPost(postId string, allowFromCache bool) ([]*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.GetForPost(postId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ReactionStore.GetForPost(postId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.PermanentDeleteBatch(endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ReactionStore.PermanentDeleteBatch(endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.Save(reaction)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.ReactionStore.Save(reaction)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) AllChannelSchemeRoles() ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.AllChannelSchemeRoles()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.AllChannelSchemeRoles()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) ChannelHigherScopedPermissions(roleNames []string) (map[string]*model.RolePermissions, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.ChannelHigherScopedPermissions(roleNames)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.ChannelHigherScopedPermissions(roleNames)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) ChannelRolesUnderTeamRole(roleName string) ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.ChannelRolesUnderTeamRole(roleName)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.ChannelRolesUnderTeamRole(roleName)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) Delete(roleId string) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.Delete(roleId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.Delete(roleId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) Get(roleId string) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.Get(roleId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.Get(roleId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) GetAll() ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.GetAll()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.GetAll()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) GetByName(name string) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.GetByName(name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.GetByName(name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) GetByNames(names []string) ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.GetByNames(names)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.GetByNames(names)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) PermanentDeleteAll() *model.AppError {

	resultVar0 := s.RoleStore.PermanentDeleteAll()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.RoleStore.PermanentDeleteAll()
	}

	return resultVar0

}

func (s *RetryLayerRoleStore) Save(role *model.Role) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.Save(role)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.RoleStore.Save(role)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) CountByScope(scope string) (int64, error) {

	resultVar0, resultVar1 := s.SchemeStore.CountByScope(scope)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.CountByScope(scope)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, error) {

	resultVar0, resultVar1 := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) Delete(schemeId string) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.Delete(schemeId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.Delete(schemeId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) Get(schemeId string) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.Get(schemeId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.Get(schemeId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.GetAllPage(scope, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.GetAllPage(scope, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.GetByName(schemeName)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.GetByName(schemeName)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) PermanentDeleteAll() error {

	resultVar0 := s.SchemeStore.PermanentDeleteAll()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.SchemeStore.PermanentDeleteAll()
	}

	return resultVar0

}

func (s *RetryLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.Save(scheme)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.SchemeStore.Save(scheme)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) AnalyticsSessionCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.AnalyticsSessionCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.AnalyticsSessionCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {

	s.SessionStore.Cleanup(expiryTime, batchSize)
	return

}

func (s *RetryLayerSessionStore) Get(sessionIdOrToken string) (*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.Get(sessionIdOrToken)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.Get(sessionIdOrToken)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) GetSessions(userId string) ([]*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.GetSessions(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.GetSessions(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) GetSessionsWithActiveDeviceIds(userId string) ([]*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.GetSessionsWithActiveDeviceIds(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.GetSessionsWithActiveDeviceIds(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) PermanentDeleteSessionsByUser(teamId string) *model.AppError {

	resultVar0 := s.SessionStore.PermanentDeleteSessionsByUser(teamId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.PermanentDeleteSessionsByUser(teamId)
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) Remove(sessionIdOrToken string) *model.AppError {

	resultVar0 := s.SessionStore.Remove(sessionIdOrToken)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.Remove(sessionIdOrToken)
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) RemoveAllSessions() *model.AppError {

	resultVar0 := s.SessionStore.RemoveAllSessions()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.RemoveAllSessions()
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) Save(session *model.Session) (*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.Save(session)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.Save(session)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) UpdateDeviceId(id string, deviceId string, expiresAt int64) (string, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) *model.AppError {

	resultVar0 := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.UpdateExpiredNotify(sessionid, notified)
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateExpiresAt(sessionId string, time int64) *model.AppError {

	resultVar0 := s.SessionStore.UpdateExpiresAt(sessionId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.UpdateExpiresAt(sessionId, time)
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateLastActivityAt(sessionId string, time int64) *model.AppError {

	resultVar0 := s.SessionStore.UpdateLastActivityAt(sessionId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.UpdateLastActivityAt(sessionId, time)
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateProps(session *model.Session) *model.AppError {

	resultVar0 := s.SessionStore.UpdateProps(session)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SessionStore.UpdateProps(session)
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateRoles(userId string, roles string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.UpdateRoles(userId, roles)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SessionStore.UpdateRoles(userId, roles)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) Get(userId string) (*model.Status, *model.AppError) {

	resultVar0, resultVar1 := s.StatusStore.Get(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.StatusStore.Get(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, *model.AppError) {

	resultVar0, resultVar1 := s.StatusStore.GetByIds(userIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.StatusStore.GetByIds(userIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) GetTotalActiveUsersCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.StatusStore.GetTotalActiveUsersCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.StatusStore.GetTotalActiveUsersCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) ResetAll() *model.AppError {

	resultVar0 := s.StatusStore.ResetAll()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.StatusStore.ResetAll()
	}

	return resultVar0

}

func (s *RetryLayerStatusStore) SaveOrUpdate(status *model.Status) *model.AppError {

	resultVar0 := s.StatusStore.SaveOrUpdate(status)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.StatusStore.SaveOrUpdate(status)
	}

	return resultVar0

}

func (s *RetryLayerStatusStore) UpdateLastActivityAt(userId string, lastActivityAt int64) *model.AppError {

	resultVar0 := s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)
	}

	return resultVar0

}

func (s *RetryLayerSystemStore) Get() (model.StringMap, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.Get()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SystemStore.Get()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) GetByName(name string) (*model.System, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.GetByName(name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SystemStore.GetByName(name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) InsertIfExists(system *model.System) (*model.System, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.InsertIfExists(system)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SystemStore.InsertIfExists(system)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) PermanentDeleteByName(name string) (*model.System, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.PermanentDeleteByName(name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.SystemStore.PermanentDeleteByName(name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) Save(system *model.System) *model.AppError {

	resultVar0 := s.SystemStore.Save(system)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SystemStore.Save(system)
	}

	return resultVar0

}

func (s *RetryLayerSystemStore) SaveOrUpdate(system *model.System) *model.AppError {

	resultVar0 := s.SystemStore.SaveOrUpdate(system)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SystemStore.SaveOrUpdate(system)
	}

	return resultVar0

}

func (s *RetryLayerSystemStore) Update(system *model.System) *model.AppError {

	resultVar0 := s.SystemStore.Update(system)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.SystemStore.Update(system)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) AnalyticsGetTeamCountForScheme(schemeId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsGetTeamCountForScheme(schemeId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.AnalyticsGetTeamCountForScheme(schemeId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) AnalyticsPrivateTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsPrivateTeamCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.AnalyticsPrivateTeamCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) AnalyticsPublicTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsPublicTeamCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.AnalyticsPublicTeamCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) AnalyticsTeamCount(includeDeleted bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsTeamCount(includeDeleted)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.AnalyticsTeamCount(includeDeleted)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) ClearAllCustomRoleAssignments() *model.AppError {

	resultVar0 := s.TeamStore.ClearAllCustomRoleAssignments()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.ClearAllCustomRoleAssignments()
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) ClearCaches() {

	s.TeamStore.ClearCaches()
	return

}

func (s *RetryLayerTeamStore) Get(id string) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetActiveMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetActiveMemberCount(teamId, restrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetActiveMemberCount(teamId, restrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAll() ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAll()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAll()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllForExportAfter(limit int, afterId string) ([]*model.TeamForExport, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllForExportAfter(limit, afterId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllForExportAfter(limit, afterId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPage(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPage(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllPage(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPrivateTeamListing() ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPrivateTeamListing()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllPrivateTeamListing()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPrivateTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPrivateTeamPageListing(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllPrivateTeamPageListing(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPublicTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPublicTeamPageListing(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllPublicTeamPageListing(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllTeamListing() ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllTeamListing()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllTeamListing()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllTeamPageListing(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetAllTeamPageListing(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetByInviteId(inviteId string) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetByInviteId(inviteId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetByInviteId(inviteId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetByName(name string) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetByName(name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetByName(name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetByNames(name []string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetByNames(name)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetByNames(name)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetChannelUnreadsForAllTeams(excludeTeamId string, userId string) ([]*model.ChannelUnread, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetChannelUnreadsForTeam(teamId string, userId string) ([]*model.ChannelUnread, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetChannelUnreadsForTeam(teamId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetChannelUnreadsForTeam(teamId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetMember(teamId string, userId string) (*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetMember(teamId, userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetMember(teamId, userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetMembers(teamId string, offset int, limit int, teamMembersGetOptions *model.TeamMembersGetOptions) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetMembers(teamId, offset, limit, teamMembersGetOptions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetMembers(teamId, offset, limit, teamMembersGetOptions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetMembersByIds(teamId string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetMembersByIds(teamId, userIds, restrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetMembersByIds(teamId, userIds, restrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamMembersForExport(userId string) ([]*model.TeamMemberForExport, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamMembersForExport(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetTeamMembersForExport(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsByScheme(schemeId string, offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsByScheme(schemeId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetTeamsByScheme(schemeId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsByUserId(userId string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsByUserId(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetTeamsByUserId(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsForUser(userId string) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsForUser(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetTeamsForUser(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsForUserWithPagination(userId string, page int, perPage int) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsForUserWithPagination(userId, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetTeamsForUserWithPagination(userId, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTotalMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTotalMemberCount(teamId, restrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetTotalMemberCount(teamId, restrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetUserTeamIds(userId string, allowFromCache bool) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetUserTeamIds(userId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GetUserTeamIds(userId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GroupSyncedTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GroupSyncedTeamCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.GroupSyncedTeamCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) InvalidateAllTeamIdsForUser(userId string) {

	s.TeamStore.InvalidateAllTeamIdsForUser(userId)
	return

}

func (s *RetryLayerTeamStore) MigrateTeamMembers(fromTeamId string, fromUserId string) (map[string]string, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.MigrateTeamMembers(fromTeamId, fromUserId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.MigrateTeamMembers(fromTeamId, fromUserId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) PermanentDelete(teamId string) *model.AppError {

	resultVar0 := s.TeamStore.PermanentDelete(teamId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.PermanentDelete(teamId)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveAllMembersByTeam(teamId string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveAllMembersByTeam(teamId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.RemoveAllMembersByTeam(teamId)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveAllMembersByUser(userId string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveAllMembersByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.RemoveAllMembersByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveMember(teamId string, userId string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveMember(teamId, userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.RemoveMember(teamId, userId)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveMembers(teamId string, userIds []string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveMembers(teamId, userIds)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.RemoveMembers(teamId, userIds)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) ResetAllTeamSchemes() *model.AppError {

	resultVar0 := s.TeamStore.ResetAllTeamSchemes()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.ResetAllTeamSchemes()
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) Save(team *model.Team) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.Save(team)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.Save(team)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SaveMember(member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SaveMember(member, maxUsersPerTeam)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.SaveMember(member, maxUsersPerTeam)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SearchAll(term string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SearchAll(term)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.SearchAll(term)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SearchAllPaged(term string, page int, perPage int) ([]*model.Team, int64, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.TeamStore.SearchAllPaged(term, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar2 == nil {
			break
		}

		break

		resultVar0, resultVar1, resultVar2 = s.TeamStore.SearchAllPaged(term, page, perPage)
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerTeamStore) SearchOpen(term string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SearchOpen(term)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.SearchOpen(term)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SearchPrivate(term string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SearchPrivate(term)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.SearchPrivate(term)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) Update(team *model.Team) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.Update(team)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.Update(team)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) UpdateLastTeamIconUpdate(teamId string, curTime int64) *model.AppError {

	resultVar0 := s.TeamStore.UpdateLastTeamIconUpdate(teamId, curTime)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.UpdateLastTeamIconUpdate(teamId, curTime)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) UpdateMember(member *model.TeamMember) (*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.UpdateMember(member)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.UpdateMember(member)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) UpdateMembersRole(teamID string, userIDs []string) *model.AppError {

	resultVar0 := s.TeamStore.UpdateMembersRole(teamID, userIDs)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TeamStore.UpdateMembersRole(teamID, userIDs)
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.UpdateMultipleMembers(members)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.UpdateMultipleMembers(members)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) UserBelongsToTeams(userId string, teamIds []string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.UserBelongsToTeams(userId, teamIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TeamStore.UserBelongsToTeams(userId, teamIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {

	resultVar0, resultVar1 := s.TermsOfServiceStore.Get(id, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.TermsOfServiceStore.Get(id, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {

	resultVar0, resultVar1 := s.TermsOfServiceStore.GetLatest(allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.TermsOfServiceStore.GetLatest(allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {

	resultVar0, resultVar1 := s.TermsOfServiceStore.Save(termsOfService)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.TermsOfServiceStore.Save(termsOfService)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTokenStore) Cleanup() {

	s.TokenStore.Cleanup()
	return

}

func (s *RetryLayerTokenStore) Delete(token string) *model.AppError {

	resultVar0 := s.TokenStore.Delete(token)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TokenStore.Delete(token)
	}

	return resultVar0

}

func (s *RetryLayerTokenStore) GetByToken(token string) (*model.Token, *model.AppError) {

	resultVar0, resultVar1 := s.TokenStore.GetByToken(token)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.TokenStore.GetByToken(token)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTokenStore) RemoveAllTokensByType(tokenType string) *model.AppError {

	resultVar0 := s.TokenStore.RemoveAllTokensByType(tokenType)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TokenStore.RemoveAllTokensByType(tokenType)
	}

	return resultVar0

}

func (s *RetryLayerTokenStore) Save(recovery *model.Token) *model.AppError {

	resultVar0 := s.TokenStore.Save(recovery)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.TokenStore.Save(recovery)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsActiveCount(time, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.AnalyticsActiveCount(time, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AnalyticsGetGuestCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetGuestCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.AnalyticsGetGuestCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetInactiveUsersCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.AnalyticsGetInactiveUsersCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AnalyticsGetSystemAdminCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetSystemAdminCount()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.AnalyticsGetSystemAdminCount()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AutocompleteUsersInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) (*model.UserAutocompleteInChannel, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AutocompleteUsersInChannel(teamId, channelId, term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.AutocompleteUsersInChannel(teamId, channelId, term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) ClearAllCustomRoleAssignments() *model.AppError {

	resultVar0 := s.UserStore.ClearAllCustomRoleAssignments()

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.ClearAllCustomRoleAssignments()
	}

	return resultVar0

}

func (s *RetryLayerUserStore) ClearCaches() {

	s.UserStore.ClearCaches()
	return

}

func (s *RetryLayerUserStore) Count(options model.UserCountOptions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Count(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.Count(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) DeactivateGuests() ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.DeactivateGuests()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.DeactivateGuests()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) DemoteUserToGuest(userID string) *model.AppError {

	resultVar0 := s.UserStore.DemoteUserToGuest(userID)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.DemoteUserToGuest(userID)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) Get(id string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Get(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.Get(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAll() ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAll()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAll()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllAfter(limit int, afterId string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllAfter(limit, afterId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAllAfter(limit, afterId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllNotInAuthService(authServices)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAllNotInAuthService(authServices)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllProfiles(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAllProfiles(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllProfilesInChannel(channelId string, allowFromCache bool) (map[string]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllProfilesInChannel(channelId, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAllProfilesInChannel(channelId, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllUsingAuthService(authService)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAllUsingAuthService(authService)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAnyUnreadPostCountForChannel(userId string, channelId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAnyUnreadPostCountForChannel(userId, channelId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetAnyUnreadPostCountForChannel(userId, channelId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetByAuth(authData, authService)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetByAuth(authData, authService)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetByEmail(email string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetByEmail(email)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetByEmail(email)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetByUsername(username string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetByUsername(username)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetByUsername(username)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetChannelGroupUsers(channelID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetChannelGroupUsers(channelID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetChannelGroupUsers(channelID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetEtagForAllProfiles() string {

	resultVar0 := s.UserStore.GetEtagForAllProfiles()

	return resultVar0

}

func (s *RetryLayerUserStore) GetEtagForProfiles(teamId string) string {

	resultVar0 := s.UserStore.GetEtagForProfiles(teamId)

	return resultVar0

}

func (s *RetryLayerUserStore) GetEtagForProfilesNotInTeam(teamId string) string {

	resultVar0 := s.UserStore.GetEtagForProfilesNotInTeam(teamId)

	return resultVar0

}

func (s *RetryLayerUserStore) GetForLogin(loginId string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetKnownUsers(userID string) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetKnownUsers(userID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetKnownUsers(userID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetNewUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetNewUsersForTeam(teamId, offset, limit, viewRestrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetNewUsersForTeam(teamId, offset, limit, viewRestrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfileByGroupChannelIdsForUser(userId string, channelIds []string) (map[string][]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfileByGroupChannelIdsForUser(userId, channelIds)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfileByGroupChannelIdsForUser(userId, channelIds)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfileByIds(userIds []string, options *UserGetByIdsOpts, allowFromCache bool) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfileByIds(userIds, options, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfileByIds(userIds, options, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfiles(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfiles(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesInChannel(channelId string, offset int, limit int) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesInChannel(channelId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfilesInChannel(channelId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesInChannelByStatus(channelId string, offset int, limit int) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesInChannelByStatus(channelId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfilesInChannelByStatus(channelId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesNotInChannel(teamId string, channelId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesNotInTeam(teamId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesWithoutTeam(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesWithoutTeam(options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetProfilesWithoutTeam(options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetRecentlyActiveUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetRecentlyActiveUsersForTeam(teamId, offset, limit, viewRestrictions)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetRecentlyActiveUsersForTeam(teamId, offset, limit, viewRestrictions)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetSystemAdminProfiles()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetSystemAdminProfiles()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetTeamGroupUsers(teamID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetTeamGroupUsers(teamID)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetTeamGroupUsers(teamID)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetUnreadCount(userId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetUnreadCount(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetUnreadCount(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetUnreadCountForChannel(userId string, channelId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetUnreadCountForChannel(userId, channelId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetUnreadCountForChannel(userId, channelId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) InferSystemInstallDate() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.InferSystemInstallDate()

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.InferSystemInstallDate()
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) InvalidateProfileCacheForUser(userId string) {

	s.UserStore.InvalidateProfileCacheForUser(userId)
	return

}

func (s *RetryLayerUserStore) InvalidateProfilesInChannelCache(channelId string) {

	s.UserStore.InvalidateProfilesInChannelCache(channelId)
	return

}

func (s *RetryLayerUserStore) InvalidateProfilesInChannelCacheByUser(userId string) {

	s.UserStore.InvalidateProfilesInChannelCacheByUser(userId)
	return

}

func (s *RetryLayerUserStore) PermanentDelete(userId string) *model.AppError {

	resultVar0 := s.UserStore.PermanentDelete(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.PermanentDelete(userId)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) PromoteGuestToUser(userID string) *model.AppError {

	resultVar0 := s.UserStore.PromoteGuestToUser(userID)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.PromoteGuestToUser(userID)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) ResetLastPictureUpdate(userId string) *model.AppError {

	resultVar0 := s.UserStore.ResetLastPictureUpdate(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.ResetLastPictureUpdate(userId)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) Save(user *model.User) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Save(user)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.Save(user)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) Search(teamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Search(teamId, term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.Search(teamId, term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchInChannel(channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchInChannel(channelId, term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.SearchInChannel(channelId, term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchInGroup(groupID, term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.SearchInGroup(groupID, term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchNotInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchNotInChannel(teamId, channelId, term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.SearchNotInChannel(teamId, channelId, term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchNotInTeam(notInTeamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchNotInTeam(notInTeamId, term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.SearchNotInTeam(notInTeamId, term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchWithoutTeam(term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchWithoutTeam(term, options)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.SearchWithoutTeam(term, options)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Update(user, allowRoleUpdate)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.Update(user, allowRoleUpdate)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) UpdateAuthData(userId string, service string, authData *string, email string, resetMfa bool) (string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) UpdateFailedPasswordAttempts(userId string, attempts int) *model.AppError {

	resultVar0 := s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateLastPictureUpdate(userId string) *model.AppError {

	resultVar0 := s.UserStore.UpdateLastPictureUpdate(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.UpdateLastPictureUpdate(userId)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateMfaActive(userId string, active bool) *model.AppError {

	resultVar0 := s.UserStore.UpdateMfaActive(userId, active)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.UpdateMfaActive(userId, active)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateMfaSecret(userId string, secret string) *model.AppError {

	resultVar0 := s.UserStore.UpdateMfaSecret(userId, secret)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.UpdateMfaSecret(userId, secret)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdatePassword(userId string, newPassword string) *model.AppError {

	resultVar0 := s.UserStore.UpdatePassword(userId, newPassword)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserStore.UpdatePassword(userId, newPassword)
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateUpdateAt(userId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.UpdateUpdateAt(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.UpdateUpdateAt(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) VerifyEmail(userId string, email string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.VerifyEmail(userId, email)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserStore.VerifyEmail(userId, email)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) Delete(tokenId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.Delete(tokenId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserAccessTokenStore.Delete(tokenId)
	}

	return resultVar0

}

func (s *RetryLayerUserAccessTokenStore) DeleteAllForUser(userId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.DeleteAllForUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserAccessTokenStore.DeleteAllForUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerUserAccessTokenStore) Get(tokenId string) (*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.Get(tokenId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserAccessTokenStore.Get(tokenId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetAll(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserAccessTokenStore.GetAll(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetByToken(tokenString)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserAccessTokenStore.GetByToken(tokenString)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) GetByUser(userId string, page int, perPage int) ([]*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetByUser(userId, page, perPage)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserAccessTokenStore.GetByUser(userId, page, perPage)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.Save(token)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserAccessTokenStore.Save(token)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.Search(term)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.UserAccessTokenStore.Search(term)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenDisable(tokenId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.UpdateTokenDisable(tokenId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserAccessTokenStore.UpdateTokenDisable(tokenId)
	}

	return resultVar0

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenEnable(tokenId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.UpdateTokenEnable(tokenId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.UserAccessTokenStore.UpdateTokenEnable(tokenId)
	}

	return resultVar0

}

func (s *RetryLayerUserTermsOfServiceStore) Delete(userId string, termsOfServiceId string) error {

	resultVar0 := s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar0 = errors.Wrap(resultVar0, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar0), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar0), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0 = s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)
	}

	return resultVar0

}

func (s *RetryLayerUserTermsOfServiceStore) GetByUser(userId string) (*model.UserTermsOfService, error) {

	resultVar0, resultVar1 := s.UserTermsOfServiceStore.GetByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.UserTermsOfServiceStore.GetByUser(userId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, error) {

	resultVar0, resultVar1 := s.UserTermsOfServiceStore.Save(userTermsOfService)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		if tries > 3 {
			break
			resultVar1 = errors.Wrap(resultVar1, "giving up after 3 consecutive repeatable transaction failures")
		}
		var pqErr *pq.Error
		var mysqlErr *mysql.MySQLError
		switch {
		case errors.As(errors.Cause(resultVar1), &pqErr):
			if pqErr.Code != "40001" && pqErr.Code != "40P01" {
				break
			}
		case errors.As(errors.Cause(resultVar1), &mysqlErr):
			if mysqlErr.Number != mySQLDeadlockCode {
				break
			}
		default:
			break
		}

		resultVar0, resultVar1 = s.UserTermsOfServiceStore.Save(userTermsOfService)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) AnalyticsIncomingCount(teamId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.AnalyticsIncomingCount(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.AnalyticsIncomingCount(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) AnalyticsOutgoingCount(teamId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.AnalyticsOutgoingCount(teamId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.AnalyticsOutgoingCount(teamId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) ClearCaches() {

	s.WebhookStore.ClearCaches()
	return

}

func (s *RetryLayerWebhookStore) DeleteIncoming(webhookId string, time int64) *model.AppError {

	resultVar0 := s.WebhookStore.DeleteIncoming(webhookId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.WebhookStore.DeleteIncoming(webhookId, time)
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) DeleteOutgoing(webhookId string, time int64) *model.AppError {

	resultVar0 := s.WebhookStore.DeleteOutgoing(webhookId, time)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.WebhookStore.DeleteOutgoing(webhookId, time)
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncoming(id, allowFromCache)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetIncoming(id, allowFromCache)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingByChannel(channelId string) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByChannel(channelId)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetIncomingByChannel(channelId)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingByTeam(teamId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByTeam(teamId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetIncomingByTeam(teamId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByTeamByUser(teamId, userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetIncomingByTeamByUser(teamId, userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingList(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetIncomingList(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingListByUser(userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingListByUser(userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetIncomingListByUser(userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoing(id)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoing(id)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByChannel(channelId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByChannel(channelId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByChannel(channelId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByChannelByUser(channelId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByChannelByUser(channelId, userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByChannelByUser(channelId, userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByTeam(teamId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByTeam(teamId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByTeam(teamId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByTeamByUser(teamId, userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByTeamByUser(teamId, userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingList(offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingList(offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingListByUser(userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) InvalidateWebhookCache(webhook string) {

	s.WebhookStore.InvalidateWebhookCache(webhook)
	return

}

func (s *RetryLayerWebhookStore) PermanentDeleteIncomingByChannel(channelId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteIncomingByChannel(channelId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.WebhookStore.PermanentDeleteIncomingByChannel(channelId)
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) PermanentDeleteIncomingByUser(userId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteIncomingByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.WebhookStore.PermanentDeleteIncomingByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) PermanentDeleteOutgoingByChannel(channelId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteOutgoingByChannel(channelId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.WebhookStore.PermanentDeleteOutgoingByChannel(channelId)
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) PermanentDeleteOutgoingByUser(userId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteOutgoingByUser(userId)

	tries := 0
	for {
		tries++
		if resultVar0 == nil {
			break
		}

		break

		resultVar0 = s.WebhookStore.PermanentDeleteOutgoingByUser(userId)
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.SaveIncoming(webhook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.SaveIncoming(webhook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.SaveOutgoing(webhook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.SaveOutgoing(webhook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.UpdateIncoming(webhook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.UpdateIncoming(webhook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.UpdateOutgoing(hook)

	tries := 0
	for {
		tries++
		if resultVar1 == nil {
			break
		}

		break

		resultVar0, resultVar1 = s.WebhookStore.UpdateOutgoing(hook)
	}

	return resultVar0, resultVar1

}

func (s *RetryLayer) Close() {
	s.Store.Close()
}

func (s *RetryLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *RetryLayer) GetCurrentSchemaVersion() string {
	return s.Store.GetCurrentSchemaVersion()
}

func (s *RetryLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *RetryLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *RetryLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *RetryLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *RetryLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *RetryLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func (s *RetryLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func NewRetryLayer(childStore Store) *RetryLayer {
	newStore := RetryLayer{
		Store: childStore,
	}

	newStore.AuditStore = &RetryLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.BotStore = &RetryLayerBotStore{BotStore: childStore.Bot(), Root: &newStore}
	newStore.ChannelStore = &RetryLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.ChannelMemberHistoryStore = &RetryLayerChannelMemberHistoryStore{ChannelMemberHistoryStore: childStore.ChannelMemberHistory(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &RetryLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &RetryLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.CommandWebhookStore = &RetryLayerCommandWebhookStore{CommandWebhookStore: childStore.CommandWebhook(), Root: &newStore}
	newStore.ComplianceStore = &RetryLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.EmojiStore = &RetryLayerEmojiStore{EmojiStore: childStore.Emoji(), Root: &newStore}
	newStore.FileInfoStore = &RetryLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.GroupStore = &RetryLayerGroupStore{GroupStore: childStore.Group(), Root: &newStore}
	newStore.JobStore = &RetryLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &RetryLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &RetryLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.OAuthStore = &RetryLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.PluginStore = &RetryLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PostStore = &RetryLayerPostStore{PostStore: childStore.Post(), Root: &newStore}
	newStore.PreferenceStore = &RetryLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ReactionStore = &RetryLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RoleStore = &RetryLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SchemeStore = &RetryLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &RetryLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.StatusStore = &RetryLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &RetryLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TeamStore = &RetryLayerTeamStore{TeamStore: childStore.Team(), Root: &newStore}
	newStore.TermsOfServiceStore = &RetryLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &RetryLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UserStore = &RetryLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &RetryLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &RetryLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &RetryLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}

// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package store

import (
	"context"

	"github.com/go-sql-driver/mysql"
	"github.com/lib/pq"
	"github.com/mattermost/mattermost-server/v5/model"
	"github.com/pkg/errors"
)

type RetryLayer struct {
	Store
	AuditStore                AuditStore
	BotStore                  BotStore
	ChannelStore              ChannelStore
	ChannelMemberHistoryStore ChannelMemberHistoryStore
	ClusterDiscoveryStore     ClusterDiscoveryStore
	CommandStore              CommandStore
	CommandWebhookStore       CommandWebhookStore
	ComplianceStore           ComplianceStore
	EmojiStore                EmojiStore
	FileInfoStore             FileInfoStore
	GroupStore                GroupStore
	JobStore                  JobStore
	LicenseStore              LicenseStore
	LinkMetadataStore         LinkMetadataStore
	OAuthStore                OAuthStore
	PluginStore               PluginStore
	PostStore                 PostStore
	PreferenceStore           PreferenceStore
	ReactionStore             ReactionStore
	RoleStore                 RoleStore
	SchemeStore               SchemeStore
	SessionStore              SessionStore
	StatusStore               StatusStore
	SystemStore               SystemStore
	TeamStore                 TeamStore
	TermsOfServiceStore       TermsOfServiceStore
	TokenStore                TokenStore
	UserStore                 UserStore
	UserAccessTokenStore      UserAccessTokenStore
	UserTermsOfServiceStore   UserTermsOfServiceStore
	WebhookStore              WebhookStore
}

func (s *RetryLayer) Audit() AuditStore {
	return s.AuditStore
}

func (s *RetryLayer) Bot() BotStore {
	return s.BotStore
}

func (s *RetryLayer) Channel() ChannelStore {
	return s.ChannelStore
}

func (s *RetryLayer) ChannelMemberHistory() ChannelMemberHistoryStore {
	return s.ChannelMemberHistoryStore
}

func (s *RetryLayer) ClusterDiscovery() ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *RetryLayer) Command() CommandStore {
	return s.CommandStore
}

func (s *RetryLayer) CommandWebhook() CommandWebhookStore {
	return s.CommandWebhookStore
}

func (s *RetryLayer) Compliance() ComplianceStore {
	return s.ComplianceStore
}

func (s *RetryLayer) Emoji() EmojiStore {
	return s.EmojiStore
}

func (s *RetryLayer) FileInfo() FileInfoStore {
	return s.FileInfoStore
}

func (s *RetryLayer) Group() GroupStore {
	return s.GroupStore
}

func (s *RetryLayer) Job() JobStore {
	return s.JobStore
}

func (s *RetryLayer) License() LicenseStore {
	return s.LicenseStore
}

func (s *RetryLayer) LinkMetadata() LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *RetryLayer) OAuth() OAuthStore {
	return s.OAuthStore
}

func (s *RetryLayer) Plugin() PluginStore {
	return s.PluginStore
}

func (s *RetryLayer) Post() PostStore {
	return s.PostStore
}

func (s *RetryLayer) Preference() PreferenceStore {
	return s.PreferenceStore
}

func (s *RetryLayer) Reaction() ReactionStore {
	return s.ReactionStore
}

func (s *RetryLayer) Role() RoleStore {
	return s.RoleStore
}

func (s *RetryLayer) Scheme() SchemeStore {
	return s.SchemeStore
}

func (s *RetryLayer) Session() SessionStore {
	return s.SessionStore
}

func (s *RetryLayer) Status() StatusStore {
	return s.StatusStore
}

func (s *RetryLayer) System() SystemStore {
	return s.SystemStore
}

func (s *RetryLayer) Team() TeamStore {
	return s.TeamStore
}

func (s *RetryLayer) TermsOfService() TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *RetryLayer) Token() TokenStore {
	return s.TokenStore
}

func (s *RetryLayer) User() UserStore {
	return s.UserStore
}

func (s *RetryLayer) UserAccessToken() UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *RetryLayer) UserTermsOfService() UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *RetryLayer) Webhook() WebhookStore {
	return s.WebhookStore
}

type RetryLayerAuditStore struct {
	AuditStore
	Root *RetryLayer
}

type RetryLayerBotStore struct {
	BotStore
	Root *RetryLayer
}

type RetryLayerChannelStore struct {
	ChannelStore
	Root *RetryLayer
}

type RetryLayerChannelMemberHistoryStore struct {
	ChannelMemberHistoryStore
	Root *RetryLayer
}

type RetryLayerClusterDiscoveryStore struct {
	ClusterDiscoveryStore
	Root *RetryLayer
}

type RetryLayerCommandStore struct {
	CommandStore
	Root *RetryLayer
}

type RetryLayerCommandWebhookStore struct {
	CommandWebhookStore
	Root *RetryLayer
}

type RetryLayerComplianceStore struct {
	ComplianceStore
	Root *RetryLayer
}

type RetryLayerEmojiStore struct {
	EmojiStore
	Root *RetryLayer
}

type RetryLayerFileInfoStore struct {
	FileInfoStore
	Root *RetryLayer
}

type RetryLayerGroupStore struct {
	GroupStore
	Root *RetryLayer
}

type RetryLayerJobStore struct {
	JobStore
	Root *RetryLayer
}

type RetryLayerLicenseStore struct {
	LicenseStore
	Root *RetryLayer
}

type RetryLayerLinkMetadataStore struct {
	LinkMetadataStore
	Root *RetryLayer
}

type RetryLayerOAuthStore struct {
	OAuthStore
	Root *RetryLayer
}

type RetryLayerPluginStore struct {
	PluginStore
	Root *RetryLayer
}

type RetryLayerPostStore struct {
	PostStore
	Root *RetryLayer
}

type RetryLayerPreferenceStore struct {
	PreferenceStore
	Root *RetryLayer
}

type RetryLayerReactionStore struct {
	ReactionStore
	Root *RetryLayer
}

type RetryLayerRoleStore struct {
	RoleStore
	Root *RetryLayer
}

type RetryLayerSchemeStore struct {
	SchemeStore
	Root *RetryLayer
}

type RetryLayerSessionStore struct {
	SessionStore
	Root *RetryLayer
}

type RetryLayerStatusStore struct {
	StatusStore
	Root *RetryLayer
}

type RetryLayerSystemStore struct {
	SystemStore
	Root *RetryLayer
}

type RetryLayerTeamStore struct {
	TeamStore
	Root *RetryLayer
}

type RetryLayerTermsOfServiceStore struct {
	TermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerTokenStore struct {
	TokenStore
	Root *RetryLayer
}

type RetryLayerUserStore struct {
	UserStore
	Root *RetryLayer
}

type RetryLayerUserAccessTokenStore struct {
	UserAccessTokenStore
	Root *RetryLayer
}

type RetryLayerUserTermsOfServiceStore struct {
	UserTermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerWebhookStore struct {
	WebhookStore
	Root *RetryLayer
}

func isRepeatableError(err error) bool {
	var pqErr *pq.Error
	var mysqlErr *mysql.MySQLError
	switch {
	case errors.As(errors.Cause(err), &pqErr):
		if pqErr.Code == "40001" || pqErr.Code == "40P01" {
			return true
		}
	case errors.As(errors.Cause(err), &mysqlErr):
		if mysqlErr.Number == mySQLDeadlockCode {
			return true
		}
	}
	return false
}

func (s *RetryLayerAuditStore) Get(user_id string, offset int, limit int) (model.Audits, error) {

	tries := 0
	for {
		result, err := s.AuditStore.Get(user_id, offset, limit)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerAuditStore) PermanentDeleteByUser(userId string) error {

	tries := 0
	for {
		err := s.AuditStore.PermanentDeleteByUser(userId)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerAuditStore) Save(audit *model.Audit) error {

	tries := 0
	for {
		err := s.AuditStore.Save(audit)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerBotStore) Get(userId string, includeDeleted bool) (*model.Bot, error) {

	tries := 0
	for {
		result, err := s.BotStore.Get(userId, includeDeleted)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerBotStore) GetAll(options *model.BotGetOptions) ([]*model.Bot, error) {

	tries := 0
	for {
		result, err := s.BotStore.GetAll(options)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerBotStore) PermanentDelete(userId string) error {

	tries := 0
	for {
		err := s.BotStore.PermanentDelete(userId)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerBotStore) Save(bot *model.Bot) (*model.Bot, error) {

	tries := 0
	for {
		result, err := s.BotStore.Save(bot)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerBotStore) Update(bot *model.Bot) (*model.Bot, error) {

	tries := 0
	for {
		result, err := s.BotStore.Update(bot)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) AnalyticsDeletedTypeCount(teamId string, channelType string) (int64, *model.AppError) {

	return s.ChannelStore.AnalyticsDeletedTypeCount(teamId, channelType)

}

func (s *RetryLayerChannelStore) AnalyticsTypeCount(teamId string, channelType string) (int64, *model.AppError) {

	return s.ChannelStore.AnalyticsTypeCount(teamId, channelType)

}

func (s *RetryLayerChannelStore) AutocompleteInTeam(teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.AutocompleteInTeam(teamId, term, includeDeleted)

}

func (s *RetryLayerChannelStore) AutocompleteInTeamForSearch(teamId string, userId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.AutocompleteInTeamForSearch(teamId, userId, term, includeDeleted)

}

func (s *RetryLayerChannelStore) ClearAllCustomRoleAssignments() *model.AppError {

	return s.ChannelStore.ClearAllCustomRoleAssignments()

}

func (s *RetryLayerChannelStore) ClearCaches() {

	s.ChannelStore.ClearCaches()

}

func (s *RetryLayerChannelStore) CountPostsAfter(channelId string, timestamp int64, userId string) (int, *model.AppError) {

	return s.ChannelStore.CountPostsAfter(channelId, timestamp, userId)

}

func (s *RetryLayerChannelStore) CreateDirectChannel(userId *model.User, otherUserId *model.User) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.CreateDirectChannel(userId, otherUserId)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) Delete(channelId string, time int64) error {

	tries := 0
	for {
		err := s.ChannelStore.Delete(channelId, time)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) Get(id string, allowFromCache bool) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.Get(id, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetAll(teamId string) ([]*model.Channel, *model.AppError) {

	return s.ChannelStore.GetAll(teamId)

}

func (s *RetryLayerChannelStore) GetAllChannelMembersForUser(userId string, allowFromCache bool, includeDeleted bool) (map[string]string, *model.AppError) {

	return s.ChannelStore.GetAllChannelMembersForUser(userId, allowFromCache, includeDeleted)

}

func (s *RetryLayerChannelStore) GetAllChannelMembersNotifyPropsForChannel(channelId string, allowFromCache bool) (map[string]model.StringMap, *model.AppError) {

	return s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelId, allowFromCache)

}

func (s *RetryLayerChannelStore) GetAllChannels(page int, perPage int, opts ChannelSearchOpts) (*model.ChannelListWithTeamData, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetAllChannels(page, perPage, opts)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetAllChannelsCount(opts ChannelSearchOpts) (int64, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetAllChannelsCount(opts)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetAllChannelsForExportAfter(limit int, afterId string) ([]*model.ChannelForExport, *model.AppError) {

	return s.ChannelStore.GetAllChannelsForExportAfter(limit, afterId)

}

func (s *RetryLayerChannelStore) GetAllDirectChannelsForExportAfter(limit int, afterId string) ([]*model.DirectChannelForExport, *model.AppError) {

	return s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterId)

}

func (s *RetryLayerChannelStore) GetByName(team_id string, name string, allowFromCache bool) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetByName(team_id, name, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetByNameIncludeDeleted(team_id string, name string, allowFromCache bool) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetByNameIncludeDeleted(team_id, name, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetByNames(team_id string, names []string, allowFromCache bool) ([]*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetByNames(team_id, names, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetChannelCounts(teamId string, userId string) (*model.ChannelCounts, *model.AppError) {

	return s.ChannelStore.GetChannelCounts(teamId, userId)

}

func (s *RetryLayerChannelStore) GetChannelMembersForExport(userId string, teamId string) ([]*model.ChannelMemberForExport, *model.AppError) {

	return s.ChannelStore.GetChannelMembersForExport(userId, teamId)

}

func (s *RetryLayerChannelStore) GetChannelMembersTimezones(channelId string) ([]model.StringMap, *model.AppError) {

	return s.ChannelStore.GetChannelMembersTimezones(channelId)

}

func (s *RetryLayerChannelStore) GetChannelUnread(channelId string, userId string) (*model.ChannelUnread, *model.AppError) {

	return s.ChannelStore.GetChannelUnread(channelId, userId)

}

func (s *RetryLayerChannelStore) GetChannels(teamId string, userId string, includeDeleted bool) (*model.ChannelList, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetChannels(teamId, userId, includeDeleted)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetChannelsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.Channel, *model.AppError) {

	return s.ChannelStore.GetChannelsBatchForIndexing(startTime, endTime, limit)

}

func (s *RetryLayerChannelStore) GetChannelsByIds(channelIds []string, includeDeleted bool) ([]*model.Channel, *model.AppError) {

	return s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)

}

func (s *RetryLayerChannelStore) GetChannelsByScheme(schemeId string, offset int, limit int) (model.ChannelList, *model.AppError) {

	return s.ChannelStore.GetChannelsByScheme(schemeId, offset, limit)

}

func (s *RetryLayerChannelStore) GetDeleted(team_id string, offset int, limit int, userId string) (*model.ChannelList, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetDeleted(team_id, offset, limit, userId)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetDeletedByName(team_id string, name string) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetDeletedByName(team_id, name)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetForPost(postId string) (*model.Channel, *model.AppError) {

	return s.ChannelStore.GetForPost(postId)

}

func (s *RetryLayerChannelStore) GetFromMaster(id string) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetFromMaster(id)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetGuestCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	return s.ChannelStore.GetGuestCount(channelId, allowFromCache)

}

func (s *RetryLayerChannelStore) GetMember(channelId string, userId string) (*model.ChannelMember, *model.AppError) {

	return s.ChannelStore.GetMember(channelId, userId)

}

func (s *RetryLayerChannelStore) GetMemberCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	return s.ChannelStore.GetMemberCount(channelId, allowFromCache)

}

func (s *RetryLayerChannelStore) GetMemberCountFromCache(channelId string) int64 {

	return s.ChannelStore.GetMemberCountFromCache(channelId)

}

func (s *RetryLayerChannelStore) GetMemberCountsByGroup(channelID string, includeTimezones bool) ([]*model.ChannelMemberCountByGroup, *model.AppError) {

	return s.ChannelStore.GetMemberCountsByGroup(channelID, includeTimezones)

}

func (s *RetryLayerChannelStore) GetMemberForPost(postId string, userId string) (*model.ChannelMember, *model.AppError) {

	return s.ChannelStore.GetMemberForPost(postId, userId)

}

func (s *RetryLayerChannelStore) GetMembers(channelId string, offset int, limit int) (*model.ChannelMembers, *model.AppError) {

	return s.ChannelStore.GetMembers(channelId, offset, limit)

}

func (s *RetryLayerChannelStore) GetMembersByIds(channelId string, userIds []string) (*model.ChannelMembers, *model.AppError) {

	return s.ChannelStore.GetMembersByIds(channelId, userIds)

}

func (s *RetryLayerChannelStore) GetMembersForUser(teamId string, userId string) (*model.ChannelMembers, *model.AppError) {

	return s.ChannelStore.GetMembersForUser(teamId, userId)

}

func (s *RetryLayerChannelStore) GetMembersForUserWithPagination(teamId string, userId string, page int, perPage int) (*model.ChannelMembers, *model.AppError) {

	return s.ChannelStore.GetMembersForUserWithPagination(teamId, userId, page, perPage)

}

func (s *RetryLayerChannelStore) GetMoreChannels(teamId string, userId string, offset int, limit int) (*model.ChannelList, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.GetMoreChannels(teamId, userId, offset, limit)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) GetPinnedPostCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	return s.ChannelStore.GetPinnedPostCount(channelId, allowFromCache)

}

func (s *RetryLayerChannelStore) GetPinnedPosts(channelId string) (*model.PostList, *model.AppError) {

	return s.ChannelStore.GetPinnedPosts(channelId)

}

func (s *RetryLayerChannelStore) GetPublicChannelsByIdsForTeam(teamId string, channelIds []string) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.GetPublicChannelsByIdsForTeam(teamId, channelIds)

}

func (s *RetryLayerChannelStore) GetPublicChannelsForTeam(teamId string, offset int, limit int) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.GetPublicChannelsForTeam(teamId, offset, limit)

}

func (s *RetryLayerChannelStore) GetTeamChannels(teamId string) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.GetTeamChannels(teamId)

}

func (s *RetryLayerChannelStore) GroupSyncedChannelCount() (int64, *model.AppError) {

	return s.ChannelStore.GroupSyncedChannelCount()

}

func (s *RetryLayerChannelStore) IncrementMentionCount(channelId string, userId string) *model.AppError {

	return s.ChannelStore.IncrementMentionCount(channelId, userId)

}

func (s *RetryLayerChannelStore) InvalidateAllChannelMembersForUser(userId string) {

	s.ChannelStore.InvalidateAllChannelMembersForUser(userId)

}

func (s *RetryLayerChannelStore) InvalidateCacheForChannelMembersNotifyProps(channelId string) {

	s.ChannelStore.InvalidateCacheForChannelMembersNotifyProps(channelId)

}

func (s *RetryLayerChannelStore) InvalidateChannel(id string) {

	s.ChannelStore.InvalidateChannel(id)

}

func (s *RetryLayerChannelStore) InvalidateChannelByName(teamId string, name string) {

	s.ChannelStore.InvalidateChannelByName(teamId, name)

}

func (s *RetryLayerChannelStore) InvalidateGuestCount(channelId string) {

	s.ChannelStore.InvalidateGuestCount(channelId)

}

func (s *RetryLayerChannelStore) InvalidateMemberCount(channelId string) {

	s.ChannelStore.InvalidateMemberCount(channelId)

}

func (s *RetryLayerChannelStore) InvalidatePinnedPostCount(channelId string) {

	s.ChannelStore.InvalidatePinnedPostCount(channelId)

}

func (s *RetryLayerChannelStore) IsUserInChannelUseCache(userId string, channelId string) bool {

	return s.ChannelStore.IsUserInChannelUseCache(userId, channelId)

}

func (s *RetryLayerChannelStore) MigrateChannelMembers(fromChannelId string, fromUserId string) (map[string]string, *model.AppError) {

	return s.ChannelStore.MigrateChannelMembers(fromChannelId, fromUserId)

}

func (s *RetryLayerChannelStore) MigratePublicChannels() error {

	tries := 0
	for {
		err := s.ChannelStore.MigratePublicChannels()
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) PermanentDelete(channelId string) error {

	tries := 0
	for {
		err := s.ChannelStore.PermanentDelete(channelId)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) PermanentDeleteByTeam(teamId string) error {

	tries := 0
	for {
		err := s.ChannelStore.PermanentDeleteByTeam(teamId)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) PermanentDeleteMembersByChannel(channelId string) *model.AppError {

	return s.ChannelStore.PermanentDeleteMembersByChannel(channelId)

}

func (s *RetryLayerChannelStore) PermanentDeleteMembersByUser(userId string) *model.AppError {

	return s.ChannelStore.PermanentDeleteMembersByUser(userId)

}

func (s *RetryLayerChannelStore) RemoveAllDeactivatedMembers(channelId string) *model.AppError {

	return s.ChannelStore.RemoveAllDeactivatedMembers(channelId)

}

func (s *RetryLayerChannelStore) RemoveMember(channelId string, userId string) *model.AppError {

	return s.ChannelStore.RemoveMember(channelId, userId)

}

func (s *RetryLayerChannelStore) RemoveMembers(channelId string, userIds []string) *model.AppError {

	return s.ChannelStore.RemoveMembers(channelId, userIds)

}

func (s *RetryLayerChannelStore) ResetAllChannelSchemes() *model.AppError {

	return s.ChannelStore.ResetAllChannelSchemes()

}

func (s *RetryLayerChannelStore) Restore(channelId string, time int64) error {

	tries := 0
	for {
		err := s.ChannelStore.Restore(channelId, time)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) Save(channel *model.Channel, maxChannelsPerTeam int64) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.Save(channel, maxChannelsPerTeam)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) SaveDirectChannel(channel *model.Channel, member1 *model.ChannelMember, member2 *model.ChannelMember) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.SaveDirectChannel(channel, member1, member2)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) SaveMember(member *model.ChannelMember) (*model.ChannelMember, *model.AppError) {

	return s.ChannelStore.SaveMember(member)

}

func (s *RetryLayerChannelStore) SaveMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, *model.AppError) {

	return s.ChannelStore.SaveMultipleMembers(members)

}

func (s *RetryLayerChannelStore) SearchAllChannels(term string, opts ChannelSearchOpts) (*model.ChannelListWithTeamData, int64, *model.AppError) {

	return s.ChannelStore.SearchAllChannels(term, opts)

}

func (s *RetryLayerChannelStore) SearchArchivedInTeam(teamId string, term string, userId string) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.SearchArchivedInTeam(teamId, term, userId)

}

func (s *RetryLayerChannelStore) SearchForUserInTeam(userId string, teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.SearchForUserInTeam(userId, teamId, term, includeDeleted)

}

func (s *RetryLayerChannelStore) SearchGroupChannels(userId string, term string) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.SearchGroupChannels(userId, term)

}

func (s *RetryLayerChannelStore) SearchInTeam(teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.SearchInTeam(teamId, term, includeDeleted)

}

func (s *RetryLayerChannelStore) SearchMore(userId string, teamId string, term string) (*model.ChannelList, *model.AppError) {

	return s.ChannelStore.SearchMore(userId, teamId, term)

}

func (s *RetryLayerChannelStore) SetDeleteAt(channelId string, deleteAt int64, updateAt int64) error {

	tries := 0
	for {
		err := s.ChannelStore.SetDeleteAt(channelId, deleteAt, updateAt)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelStore) Update(channel *model.Channel) (*model.Channel, error) {

	tries := 0
	for {
		result, err := s.ChannelStore.Update(channel)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelStore) UpdateLastViewedAt(channelIds []string, userId string) (map[string]int64, *model.AppError) {

	return s.ChannelStore.UpdateLastViewedAt(channelIds, userId)

}

func (s *RetryLayerChannelStore) UpdateLastViewedAtPost(unreadPost *model.Post, userID string, mentionCount int) (*model.ChannelUnreadAt, *model.AppError) {

	return s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount)

}

func (s *RetryLayerChannelStore) UpdateMember(member *model.ChannelMember) (*model.ChannelMember, *model.AppError) {

	return s.ChannelStore.UpdateMember(member)

}

func (s *RetryLayerChannelStore) UpdateMembersRole(channelID string, userIDs []string) *model.AppError {

	return s.ChannelStore.UpdateMembersRole(channelID, userIDs)

}

func (s *RetryLayerChannelStore) UpdateMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, *model.AppError) {

	return s.ChannelStore.UpdateMultipleMembers(members)

}

func (s *RetryLayerChannelStore) UserBelongsToChannels(userId string, channelIds []string) (bool, *model.AppError) {

	return s.ChannelStore.UserBelongsToChannels(userId, channelIds)

}

func (s *RetryLayerChannelMemberHistoryStore) GetUsersInChannelDuring(startTime int64, endTime int64, channelId string) ([]*model.ChannelMemberHistoryResult, error) {

	tries := 0
	for {
		result, err := s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelId)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerChannelMemberHistoryStore) LogJoinEvent(userId string, channelId string, joinTime int64) error {

	tries := 0
	for {
		err := s.ChannelMemberHistoryStore.LogJoinEvent(userId, channelId, joinTime)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelMemberHistoryStore) LogLeaveEvent(userId string, channelId string, leaveTime int64) error {

	tries := 0
	for {
		err := s.ChannelMemberHistoryStore.LogLeaveEvent(userId, channelId, leaveTime)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerChannelMemberHistoryStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {

	tries := 0
	for {
		result, err := s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerClusterDiscoveryStore) Cleanup() *model.AppError {

	return s.ClusterDiscoveryStore.Cleanup()

}

func (s *RetryLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, *model.AppError) {

	return s.ClusterDiscoveryStore.Delete(discovery)

}

func (s *RetryLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, *model.AppError) {

	return s.ClusterDiscoveryStore.Exists(discovery)

}

func (s *RetryLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, *model.AppError) {

	return s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

}

func (s *RetryLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) *model.AppError {

	return s.ClusterDiscoveryStore.Save(discovery)

}

func (s *RetryLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) *model.AppError {

	return s.ClusterDiscoveryStore.SetLastPingAt(discovery)

}

func (s *RetryLayerCommandStore) AnalyticsCommandCount(teamId string) (int64, *model.AppError) {

	return s.CommandStore.AnalyticsCommandCount(teamId)

}

func (s *RetryLayerCommandStore) Delete(commandId string, time int64) *model.AppError {

	return s.CommandStore.Delete(commandId, time)

}

func (s *RetryLayerCommandStore) Get(id string) (*model.Command, *model.AppError) {

	return s.CommandStore.Get(id)

}

func (s *RetryLayerCommandStore) GetByTeam(teamId string) ([]*model.Command, *model.AppError) {

	return s.CommandStore.GetByTeam(teamId)

}

func (s *RetryLayerCommandStore) GetByTrigger(teamId string, trigger string) (*model.Command, *model.AppError) {

	return s.CommandStore.GetByTrigger(teamId, trigger)

}

func (s *RetryLayerCommandStore) PermanentDeleteByTeam(teamId string) *model.AppError {

	return s.CommandStore.PermanentDeleteByTeam(teamId)

}

func (s *RetryLayerCommandStore) PermanentDeleteByUser(userId string) *model.AppError {

	return s.CommandStore.PermanentDeleteByUser(userId)

}

func (s *RetryLayerCommandStore) Save(webhook *model.Command) (*model.Command, *model.AppError) {

	return s.CommandStore.Save(webhook)

}

func (s *RetryLayerCommandStore) Update(hook *model.Command) (*model.Command, *model.AppError) {

	return s.CommandStore.Update(hook)

}

func (s *RetryLayerCommandWebhookStore) Cleanup() {

	s.CommandWebhookStore.Cleanup()

}

func (s *RetryLayerCommandWebhookStore) Get(id string) (*model.CommandWebhook, *model.AppError) {

	return s.CommandWebhookStore.Get(id)

}

func (s *RetryLayerCommandWebhookStore) Save(webhook *model.CommandWebhook) (*model.CommandWebhook, *model.AppError) {

	return s.CommandWebhookStore.Save(webhook)

}

func (s *RetryLayerCommandWebhookStore) TryUse(id string, limit int) *model.AppError {

	return s.CommandWebhookStore.TryUse(id, limit)

}

func (s *RetryLayerComplianceStore) ComplianceExport(compliance *model.Compliance) ([]*model.CompliancePost, *model.AppError) {

	return s.ComplianceStore.ComplianceExport(compliance)

}

func (s *RetryLayerComplianceStore) Get(id string) (*model.Compliance, *model.AppError) {

	return s.ComplianceStore.Get(id)

}

func (s *RetryLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, *model.AppError) {

	return s.ComplianceStore.GetAll(offset, limit)

}

func (s *RetryLayerComplianceStore) MessageExport(after int64, limit int) ([]*model.MessageExport, *model.AppError) {

	return s.ComplianceStore.MessageExport(after, limit)

}

func (s *RetryLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, *model.AppError) {

	return s.ComplianceStore.Save(compliance)

}

func (s *RetryLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, *model.AppError) {

	return s.ComplianceStore.Update(compliance)

}

func (s *RetryLayerEmojiStore) Delete(emoji *model.Emoji, time int64) error {

	tries := 0
	for {
		err := s.EmojiStore.Delete(emoji, time)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerEmojiStore) Get(id string, allowFromCache bool) (*model.Emoji, error) {

	tries := 0
	for {
		result, err := s.EmojiStore.Get(id, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerEmojiStore) GetByName(name string, allowFromCache bool) (*model.Emoji, error) {

	tries := 0
	for {
		result, err := s.EmojiStore.GetByName(name, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerEmojiStore) GetList(offset int, limit int, sort string) ([]*model.Emoji, error) {

	tries := 0
	for {
		result, err := s.EmojiStore.GetList(offset, limit, sort)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerEmojiStore) GetMultipleByName(names []string) ([]*model.Emoji, error) {

	tries := 0
	for {
		result, err := s.EmojiStore.GetMultipleByName(names)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerEmojiStore) Save(emoji *model.Emoji) (*model.Emoji, error) {

	tries := 0
	for {
		result, err := s.EmojiStore.Save(emoji)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerEmojiStore) Search(name string, prefixOnly bool, limit int) ([]*model.Emoji, error) {

	tries := 0
	for {
		result, err := s.EmojiStore.Search(name, prefixOnly, limit)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerFileInfoStore) AttachToPost(fileId string, postId string, creatorId string) *model.AppError {

	return s.FileInfoStore.AttachToPost(fileId, postId, creatorId)

}

func (s *RetryLayerFileInfoStore) ClearCaches() {

	s.FileInfoStore.ClearCaches()

}

func (s *RetryLayerFileInfoStore) DeleteForPost(postId string) (string, *model.AppError) {

	return s.FileInfoStore.DeleteForPost(postId)

}

func (s *RetryLayerFileInfoStore) Get(id string) (*model.FileInfo, *model.AppError) {

	return s.FileInfoStore.Get(id)

}

func (s *RetryLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, *model.AppError) {

	return s.FileInfoStore.GetByPath(path)

}

func (s *RetryLayerFileInfoStore) GetForPost(postId string, readFromMaster bool, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, *model.AppError) {

	return s.FileInfoStore.GetForPost(postId, readFromMaster, includeDeleted, allowFromCache)

}

func (s *RetryLayerFileInfoStore) GetForUser(userId string) ([]*model.FileInfo, *model.AppError) {

	return s.FileInfoStore.GetForUser(userId)

}

func (s *RetryLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, *model.AppError) {

	return s.FileInfoStore.GetWithOptions(page, perPage, opt)

}

func (s *RetryLayerFileInfoStore) InvalidateFileInfosForPostCache(postId string, deleted bool) {

	s.FileInfoStore.InvalidateFileInfosForPostCache(postId, deleted)

}

func (s *RetryLayerFileInfoStore) PermanentDelete(fileId string) *model.AppError {

	return s.FileInfoStore.PermanentDelete(fileId)

}

func (s *RetryLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	return s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

}

func (s *RetryLayerFileInfoStore) PermanentDeleteByUser(userId string) (int64, *model.AppError) {

	return s.FileInfoStore.PermanentDeleteByUser(userId)

}

func (s *RetryLayerFileInfoStore) Save(info *model.FileInfo) (*model.FileInfo, *model.AppError) {

	return s.FileInfoStore.Save(info)

}

func (s *RetryLayerGroupStore) AdminRoleGroupsForSyncableMember(userID string, syncableID string, syncableType model.GroupSyncableType) ([]string, *model.AppError) {

	return s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)

}

func (s *RetryLayerGroupStore) ChannelMembersMinusGroupMembers(channelID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, *model.AppError) {

	return s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)

}

func (s *RetryLayerGroupStore) ChannelMembersToAdd(since int64, channelID *string) ([]*model.UserChannelIDPair, *model.AppError) {

	return s.GroupStore.ChannelMembersToAdd(since, channelID)

}

func (s *RetryLayerGroupStore) ChannelMembersToRemove(channelID *string) ([]*model.ChannelMember, *model.AppError) {

	return s.GroupStore.ChannelMembersToRemove(channelID)

}

func (s *RetryLayerGroupStore) CountChannelMembersMinusGroupMembers(channelID string, groupIDs []string) (int64, *model.AppError) {

	return s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)

}

func (s *RetryLayerGroupStore) CountGroupsByChannel(channelId string, opts model.GroupSearchOpts) (int64, *model.AppError) {

	return s.GroupStore.CountGroupsByChannel(channelId, opts)

}

func (s *RetryLayerGroupStore) CountGroupsByTeam(teamId string, opts model.GroupSearchOpts) (int64, *model.AppError) {

	return s.GroupStore.CountGroupsByTeam(teamId, opts)

}

func (s *RetryLayerGroupStore) CountTeamMembersMinusGroupMembers(teamID string, groupIDs []string) (int64, *model.AppError) {

	return s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)

}

func (s *RetryLayerGroupStore) Create(group *model.Group) (*model.Group, *model.AppError) {

	return s.GroupStore.Create(group)

}

func (s *RetryLayerGroupStore) CreateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, *model.AppError) {

	return s.GroupStore.CreateGroupSyncable(groupSyncable)

}

func (s *RetryLayerGroupStore) Delete(groupID string) (*model.Group, *model.AppError) {

	return s.GroupStore.Delete(groupID)

}

func (s *RetryLayerGroupStore) DeleteGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, *model.AppError) {

	return s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)

}

func (s *RetryLayerGroupStore) DeleteMember(groupID string, userID string) (*model.GroupMember, *model.AppError) {

	return s.GroupStore.DeleteMember(groupID, userID)

}

func (s *RetryLayerGroupStore) DistinctGroupMemberCount() (int64, *model.AppError) {

	return s.GroupStore.DistinctGroupMemberCount()

}

func (s *RetryLayerGroupStore) Get(groupID string) (*model.Group, *model.AppError) {

	return s.GroupStore.Get(groupID)

}

func (s *RetryLayerGroupStore) GetAllBySource(groupSource model.GroupSource) ([]*model.Group, *model.AppError) {

	return s.GroupStore.GetAllBySource(groupSource)

}

func (s *RetryLayerGroupStore) GetAllGroupSyncablesByGroupId(groupID string, syncableType model.GroupSyncableType) ([]*model.GroupSyncable, *model.AppError) {

	return s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)

}

func (s *RetryLayerGroupStore) GetByIDs(groupIDs []string) ([]*model.Group, *model.AppError) {

	return s.GroupStore.GetByIDs(groupIDs)

}

func (s *RetryLayerGroupStore) GetByName(name string, opts model.GroupSearchOpts) (*model.Group, *model.AppError) {

	return s.GroupStore.GetByName(name, opts)

}

func (s *RetryLayerGroupStore) GetByRemoteID(remoteID string, groupSource model.GroupSource) (*model.Group, *model.AppError) {

	return s.GroupStore.GetByRemoteID(remoteID, groupSource)

}

func (s *RetryLayerGroupStore) GetByUser(userId string) ([]*model.Group, *model.AppError) {

	return s.GroupStore.GetByUser(userId)

}

func (s *RetryLayerGroupStore) GetGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, *model.AppError) {

	return s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)

}

func (s *RetryLayerGroupStore) GetGroups(page int, perPage int, opts model.GroupSearchOpts) ([]*model.Group, *model.AppError) {

	return s.GroupStore.GetGroups(page, perPage, opts)

}

func (s *RetryLayerGroupStore) GetGroupsAssociatedToChannelsByTeam(teamId string, opts model.GroupSearchOpts) (map[string][]*model.GroupWithSchemeAdmin, *model.AppError) {

	return s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamId, opts)

}

func (s *RetryLayerGroupStore) GetGroupsByChannel(channelId string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, *model.AppError) {

	return s.GroupStore.GetGroupsByChannel(channelId, opts)

}

func (s *RetryLayerGroupStore) GetGroupsByTeam(teamId string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, *model.AppError) {

	return s.GroupStore.GetGroupsByTeam(teamId, opts)

}

func (s *RetryLayerGroupStore) GetMemberCount(groupID string) (int64, *model.AppError) {

	return s.GroupStore.GetMemberCount(groupID)

}

func (s *RetryLayerGroupStore) GetMemberUsers(groupID string) ([]*model.User, *model.AppError) {

	return s.GroupStore.GetMemberUsers(groupID)

}

func (s *RetryLayerGroupStore) GetMemberUsersInTeam(groupID string, teamID string) ([]*model.User, *model.AppError) {

	return s.GroupStore.GetMemberUsersInTeam(groupID, teamID)

}

func (s *RetryLayerGroupStore) GetMemberUsersNotInChannel(groupID string, channelID string) ([]*model.User, *model.AppError) {

	return s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)

}

func (s *RetryLayerGroupStore) GetMemberUsersPage(groupID string, page int, perPage int) ([]*model.User, *model.AppError) {

	return s.GroupStore.GetMemberUsersPage(groupID, page, perPage)

}

func (s *RetryLayerGroupStore) GroupChannelCount() (int64, *model.AppError) {

	return s.GroupStore.GroupChannelCount()

}

func (s *RetryLayerGroupStore) GroupCount() (int64, *model.AppError) {

	return s.GroupStore.GroupCount()

}

func (s *RetryLayerGroupStore) GroupCountWithAllowReference() (int64, *model.AppError) {

	return s.GroupStore.GroupCountWithAllowReference()

}

func (s *RetryLayerGroupStore) GroupMemberCount() (int64, *model.AppError) {

	return s.GroupStore.GroupMemberCount()

}

func (s *RetryLayerGroupStore) GroupTeamCount() (int64, *model.AppError) {

	return s.GroupStore.GroupTeamCount()

}

func (s *RetryLayerGroupStore) PermanentDeleteMembersByUser(userId string) *model.AppError {

	return s.GroupStore.PermanentDeleteMembersByUser(userId)

}

func (s *RetryLayerGroupStore) PermittedSyncableAdmins(syncableID string, syncableType model.GroupSyncableType) ([]string, *model.AppError) {

	return s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)

}

func (s *RetryLayerGroupStore) TeamMembersMinusGroupMembers(teamID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, *model.AppError) {

	return s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)

}

func (s *RetryLayerGroupStore) TeamMembersToAdd(since int64, teamID *string) ([]*model.UserTeamIDPair, *model.AppError) {

	return s.GroupStore.TeamMembersToAdd(since, teamID)

}

func (s *RetryLayerGroupStore) TeamMembersToRemove(teamID *string) ([]*model.TeamMember, *model.AppError) {

	return s.GroupStore.TeamMembersToRemove(teamID)

}

func (s *RetryLayerGroupStore) Update(group *model.Group) (*model.Group, *model.AppError) {

	return s.GroupStore.Update(group)

}

func (s *RetryLayerGroupStore) UpdateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, *model.AppError) {

	return s.GroupStore.UpdateGroupSyncable(groupSyncable)

}

func (s *RetryLayerGroupStore) UpsertMember(groupID string, userID string) (*model.GroupMember, *model.AppError) {

	return s.GroupStore.UpsertMember(groupID, userID)

}

func (s *RetryLayerJobStore) Delete(id string) (string, *model.AppError) {

	return s.JobStore.Delete(id)

}

func (s *RetryLayerJobStore) Get(id string) (*model.Job, *model.AppError) {

	return s.JobStore.Get(id)

}

func (s *RetryLayerJobStore) GetAllByStatus(status string) ([]*model.Job, *model.AppError) {

	return s.JobStore.GetAllByStatus(status)

}

func (s *RetryLayerJobStore) GetAllByType(jobType string) ([]*model.Job, *model.AppError) {

	return s.JobStore.GetAllByType(jobType)

}

func (s *RetryLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, *model.AppError) {

	return s.JobStore.GetAllByTypePage(jobType, offset, limit)

}

func (s *RetryLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, *model.AppError) {

	return s.JobStore.GetAllPage(offset, limit)

}

func (s *RetryLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, *model.AppError) {

	return s.JobStore.GetCountByStatusAndType(status, jobType)

}

func (s *RetryLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, *model.AppError) {

	return s.JobStore.GetNewestJobByStatusAndType(status, jobType)

}

func (s *RetryLayerJobStore) Save(job *model.Job) (*model.Job, *model.AppError) {

	return s.JobStore.Save(job)

}

func (s *RetryLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, *model.AppError) {

	return s.JobStore.UpdateOptimistically(job, currentStatus)

}

func (s *RetryLayerJobStore) UpdateStatus(id string, status string) (*model.Job, *model.AppError) {

	return s.JobStore.UpdateStatus(id, status)

}

func (s *RetryLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, *model.AppError) {

	return s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

}

func (s *RetryLayerLicenseStore) Get(id string) (*model.LicenseRecord, error) {

	tries := 0
	for {
		result, err := s.LicenseStore.Get(id)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerLicenseStore) Save(license *model.LicenseRecord) (*model.LicenseRecord, error) {

	tries := 0
	for {
		result, err := s.LicenseStore.Save(license)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, error) {

	tries := 0
	for {
		result, err := s.LinkMetadataStore.Get(url, timestamp)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, error) {

	tries := 0
	for {
		result, err := s.LinkMetadataStore.Save(linkMetadata)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerOAuthStore) DeleteApp(id string) *model.AppError {

	return s.OAuthStore.DeleteApp(id)

}

func (s *RetryLayerOAuthStore) GetAccessData(token string) (*model.AccessData, *model.AppError) {

	return s.OAuthStore.GetAccessData(token)

}

func (s *RetryLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, *model.AppError) {

	return s.OAuthStore.GetAccessDataByRefreshToken(token)

}

func (s *RetryLayerOAuthStore) GetAccessDataByUserForApp(userId string, clientId string) ([]*model.AccessData, *model.AppError) {

	return s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)

}

func (s *RetryLayerOAuthStore) GetApp(id string) (*model.OAuthApp, *model.AppError) {

	return s.OAuthStore.GetApp(id)

}

func (s *RetryLayerOAuthStore) GetAppByUser(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	return s.OAuthStore.GetAppByUser(userId, offset, limit)

}

func (s *RetryLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	return s.OAuthStore.GetApps(offset, limit)

}

func (s *RetryLayerOAuthStore) GetAuthData(code string) (*model.AuthData, *model.AppError) {

	return s.OAuthStore.GetAuthData(code)

}

func (s *RetryLayerOAuthStore) GetAuthorizedApps(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	return s.OAuthStore.GetAuthorizedApps(userId, offset, limit)

}

func (s *RetryLayerOAuthStore) GetPreviousAccessData(userId string, clientId string) (*model.AccessData, *model.AppError) {

	return s.OAuthStore.GetPreviousAccessData(userId, clientId)

}

func (s *RetryLayerOAuthStore) PermanentDeleteAuthDataByUser(userId string) *model.AppError {

	return s.OAuthStore.PermanentDeleteAuthDataByUser(userId)

}

func (s *RetryLayerOAuthStore) RemoveAccessData(token string) *model.AppError {

	return s.OAuthStore.RemoveAccessData(token)

}

func (s *RetryLayerOAuthStore) RemoveAllAccessData() *model.AppError {

	return s.OAuthStore.RemoveAllAccessData()

}

func (s *RetryLayerOAuthStore) RemoveAuthData(code string) *model.AppError {

	return s.OAuthStore.RemoveAuthData(code)

}

func (s *RetryLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {

	return s.OAuthStore.SaveAccessData(accessData)

}

func (s *RetryLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {

	return s.OAuthStore.SaveApp(app)

}

func (s *RetryLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, *model.AppError) {

	return s.OAuthStore.SaveAuthData(authData)

}

func (s *RetryLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {

	return s.OAuthStore.UpdateAccessData(accessData)

}

func (s *RetryLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {

	return s.OAuthStore.UpdateApp(app)

}

func (s *RetryLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, *model.AppError) {

	return s.PluginStore.CompareAndDelete(keyVal, oldValue)

}

func (s *RetryLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, *model.AppError) {

	return s.PluginStore.CompareAndSet(keyVal, oldValue)

}

func (s *RetryLayerPluginStore) Delete(pluginId string, key string) *model.AppError {

	return s.PluginStore.Delete(pluginId, key)

}

func (s *RetryLayerPluginStore) DeleteAllExpired() *model.AppError {

	return s.PluginStore.DeleteAllExpired()

}

func (s *RetryLayerPluginStore) DeleteAllForPlugin(PluginId string) *model.AppError {

	return s.PluginStore.DeleteAllForPlugin(PluginId)

}

func (s *RetryLayerPluginStore) Get(pluginId string, key string) (*model.PluginKeyValue, *model.AppError) {

	return s.PluginStore.Get(pluginId, key)

}

func (s *RetryLayerPluginStore) List(pluginId string, page int, perPage int) ([]string, *model.AppError) {

	return s.PluginStore.List(pluginId, page, perPage)

}

func (s *RetryLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, *model.AppError) {

	return s.PluginStore.SaveOrUpdate(keyVal)

}

func (s *RetryLayerPluginStore) SetWithOptions(pluginId string, key string, value []byte, options model.PluginKVSetOptions) (bool, *model.AppError) {

	return s.PluginStore.SetWithOptions(pluginId, key, value, options)

}

func (s *RetryLayerPostStore) AnalyticsPostCount(teamId string, mustHaveFile bool, mustHaveHashtag bool) (int64, *model.AppError) {

	return s.PostStore.AnalyticsPostCount(teamId, mustHaveFile, mustHaveHashtag)

}

func (s *RetryLayerPostStore) AnalyticsPostCountsByDay(options *model.AnalyticsPostCountsOptions) (model.AnalyticsRows, *model.AppError) {

	return s.PostStore.AnalyticsPostCountsByDay(options)

}

func (s *RetryLayerPostStore) AnalyticsUserCountsWithPostsByDay(teamId string) (model.AnalyticsRows, *model.AppError) {

	return s.PostStore.AnalyticsUserCountsWithPostsByDay(teamId)

}

func (s *RetryLayerPostStore) ClearCaches() {

	s.PostStore.ClearCaches()

}

func (s *RetryLayerPostStore) Delete(postId string, time int64, deleteByID string) *model.AppError {

	return s.PostStore.Delete(postId, time, deleteByID)

}

func (s *RetryLayerPostStore) Get(id string, skipFetchThreads bool) (*model.PostList, *model.AppError) {

	return s.PostStore.Get(id, skipFetchThreads)

}

func (s *RetryLayerPostStore) GetDirectPostParentsForExportAfter(limit int, afterId string) ([]*model.DirectPostForExport, *model.AppError) {

	return s.PostStore.GetDirectPostParentsForExportAfter(limit, afterId)

}

func (s *RetryLayerPostStore) GetEtag(channelId string, allowFromCache bool) string {

	return s.PostStore.GetEtag(channelId, allowFromCache)

}

func (s *RetryLayerPostStore) GetFlaggedPosts(userId string, offset int, limit int) (*model.PostList, *model.AppError) {

	return s.PostStore.GetFlaggedPosts(userId, offset, limit)

}

func (s *RetryLayerPostStore) GetFlaggedPostsForChannel(userId string, channelId string, offset int, limit int) (*model.PostList, *model.AppError) {

	return s.PostStore.GetFlaggedPostsForChannel(userId, channelId, offset, limit)

}

func (s *RetryLayerPostStore) GetFlaggedPostsForTeam(userId string, teamId string, offset int, limit int) (*model.PostList, *model.AppError) {

	return s.PostStore.GetFlaggedPostsForTeam(userId, teamId, offset, limit)

}

func (s *RetryLayerPostStore) GetMaxPostSize() int {

	return s.PostStore.GetMaxPostSize()

}

func (s *RetryLayerPostStore) GetOldest() (*model.Post, *model.AppError) {

	return s.PostStore.GetOldest()

}

func (s *RetryLayerPostStore) GetOldestEntityCreationTime() (int64, *model.AppError) {

	return s.PostStore.GetOldestEntityCreationTime()

}

func (s *RetryLayerPostStore) GetParentsForExportAfter(limit int, afterId string) ([]*model.PostForExport, *model.AppError) {

	return s.PostStore.GetParentsForExportAfter(limit, afterId)

}

func (s *RetryLayerPostStore) GetPostAfterTime(channelId string, time int64) (*model.Post, *model.AppError) {

	return s.PostStore.GetPostAfterTime(channelId, time)

}

func (s *RetryLayerPostStore) GetPostIdAfterTime(channelId string, time int64) (string, *model.AppError) {

	return s.PostStore.GetPostIdAfterTime(channelId, time)

}

func (s *RetryLayerPostStore) GetPostIdBeforeTime(channelId string, time int64) (string, *model.AppError) {

	return s.PostStore.GetPostIdBeforeTime(channelId, time)

}

func (s *RetryLayerPostStore) GetPosts(options model.GetPostsOptions, allowFromCache bool) (*model.PostList, *model.AppError) {

	return s.PostStore.GetPosts(options, allowFromCache)

}

func (s *RetryLayerPostStore) GetPostsAfter(options model.GetPostsOptions) (*model.PostList, *model.AppError) {

	return s.PostStore.GetPostsAfter(options)

}

func (s *RetryLayerPostStore) GetPostsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.PostForIndexing, *model.AppError) {

	return s.PostStore.GetPostsBatchForIndexing(startTime, endTime, limit)

}

func (s *RetryLayerPostStore) GetPostsBefore(options model.GetPostsOptions) (*model.PostList, *model.AppError) {

	return s.PostStore.GetPostsBefore(options)

}

func (s *RetryLayerPostStore) GetPostsByIds(postIds []string) ([]*model.Post, *model.AppError) {

	return s.PostStore.GetPostsByIds(postIds)

}

func (s *RetryLayerPostStore) GetPostsCreatedAt(channelId string, time int64) ([]*model.Post, *model.AppError) {

	return s.PostStore.GetPostsCreatedAt(channelId, time)

}

func (s *RetryLayerPostStore) GetPostsSince(options model.GetPostsSinceOptions, allowFromCache bool) (*model.PostList, *model.AppError) {

	return s.PostStore.GetPostsSince(options, allowFromCache)

}

func (s *RetryLayerPostStore) GetRepliesForExport(parentId string) ([]*model.ReplyForExport, *model.AppError) {

	return s.PostStore.GetRepliesForExport(parentId)

}

func (s *RetryLayerPostStore) GetSingle(id string) (*model.Post, *model.AppError) {

	return s.PostStore.GetSingle(id)

}

func (s *RetryLayerPostStore) InvalidateLastPostTimeCache(channelId string) {

	s.PostStore.InvalidateLastPostTimeCache(channelId)

}

func (s *RetryLayerPostStore) Overwrite(post *model.Post) (*model.Post, *model.AppError) {

	return s.PostStore.Overwrite(post)

}

func (s *RetryLayerPostStore) OverwriteMultiple(posts []*model.Post) ([]*model.Post, int, *model.AppError) {

	return s.PostStore.OverwriteMultiple(posts)

}

func (s *RetryLayerPostStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	return s.PostStore.PermanentDeleteBatch(endTime, limit)

}

func (s *RetryLayerPostStore) PermanentDeleteByChannel(channelId string) *model.AppError {

	return s.PostStore.PermanentDeleteByChannel(channelId)

}

func (s *RetryLayerPostStore) PermanentDeleteByUser(userId string) *model.AppError {

	return s.PostStore.PermanentDeleteByUser(userId)

}

func (s *RetryLayerPostStore) Save(post *model.Post) (*model.Post, *model.AppError) {

	return s.PostStore.Save(post)

}

func (s *RetryLayerPostStore) SaveMultiple(posts []*model.Post) ([]*model.Post, int, *model.AppError) {

	return s.PostStore.SaveMultiple(posts)

}

func (s *RetryLayerPostStore) Search(teamId string, userId string, params *model.SearchParams) (*model.PostList, *model.AppError) {

	return s.PostStore.Search(teamId, userId, params)

}

func (s *RetryLayerPostStore) SearchPostsInTeamForUser(paramsList []*model.SearchParams, userId string, teamId string, isOrSearch bool, includeDeletedChannels bool, page int, perPage int) (*model.PostSearchResults, *model.AppError) {

	return s.PostStore.SearchPostsInTeamForUser(paramsList, userId, teamId, isOrSearch, includeDeletedChannels, page, perPage)

}

func (s *RetryLayerPostStore) Update(newPost *model.Post, oldPost *model.Post) (*model.Post, *model.AppError) {

	return s.PostStore.Update(newPost, oldPost)

}

func (s *RetryLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, *model.AppError) {

	return s.PreferenceStore.CleanupFlagsBatch(limit)

}

func (s *RetryLayerPreferenceStore) Delete(userId string, category string, name string) *model.AppError {

	return s.PreferenceStore.Delete(userId, category, name)

}

func (s *RetryLayerPreferenceStore) DeleteCategory(userId string, category string) *model.AppError {

	return s.PreferenceStore.DeleteCategory(userId, category)

}

func (s *RetryLayerPreferenceStore) DeleteCategoryAndName(category string, name string) *model.AppError {

	return s.PreferenceStore.DeleteCategoryAndName(category, name)

}

func (s *RetryLayerPreferenceStore) Get(userId string, category string, name string) (*model.Preference, *model.AppError) {

	return s.PreferenceStore.Get(userId, category, name)

}

func (s *RetryLayerPreferenceStore) GetAll(userId string) (model.Preferences, *model.AppError) {

	return s.PreferenceStore.GetAll(userId)

}

func (s *RetryLayerPreferenceStore) GetCategory(userId string, category string) (model.Preferences, *model.AppError) {

	return s.PreferenceStore.GetCategory(userId, category)

}

func (s *RetryLayerPreferenceStore) PermanentDeleteByUser(userId string) *model.AppError {

	return s.PreferenceStore.PermanentDeleteByUser(userId)

}

func (s *RetryLayerPreferenceStore) Save(preferences *model.Preferences) *model.AppError {

	return s.PreferenceStore.Save(preferences)

}

func (s *RetryLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, error) {

	tries := 0
	for {
		result, err := s.ReactionStore.BulkGetForPosts(postIds)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, error) {

	tries := 0
	for {
		result, err := s.ReactionStore.Delete(reaction)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerReactionStore) DeleteAllWithEmojiName(emojiName string) error {

	tries := 0
	for {
		err := s.ReactionStore.DeleteAllWithEmojiName(emojiName)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerReactionStore) GetForPost(postId string, allowFromCache bool) ([]*model.Reaction, error) {

	tries := 0
	for {
		result, err := s.ReactionStore.GetForPost(postId, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {

	tries := 0
	for {
		result, err := s.ReactionStore.PermanentDeleteBatch(endTime, limit)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, error) {

	tries := 0
	for {
		result, err := s.ReactionStore.Save(reaction)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerRoleStore) AllChannelSchemeRoles() ([]*model.Role, *model.AppError) {

	return s.RoleStore.AllChannelSchemeRoles()

}

func (s *RetryLayerRoleStore) ChannelHigherScopedPermissions(roleNames []string) (map[string]*model.RolePermissions, *model.AppError) {

	return s.RoleStore.ChannelHigherScopedPermissions(roleNames)

}

func (s *RetryLayerRoleStore) ChannelRolesUnderTeamRole(roleName string) ([]*model.Role, *model.AppError) {

	return s.RoleStore.ChannelRolesUnderTeamRole(roleName)

}

func (s *RetryLayerRoleStore) Delete(roleId string) (*model.Role, *model.AppError) {

	return s.RoleStore.Delete(roleId)

}

func (s *RetryLayerRoleStore) Get(roleId string) (*model.Role, *model.AppError) {

	return s.RoleStore.Get(roleId)

}

func (s *RetryLayerRoleStore) GetAll() ([]*model.Role, *model.AppError) {

	return s.RoleStore.GetAll()

}

func (s *RetryLayerRoleStore) GetByName(name string) (*model.Role, *model.AppError) {

	return s.RoleStore.GetByName(name)

}

func (s *RetryLayerRoleStore) GetByNames(names []string) ([]*model.Role, *model.AppError) {

	return s.RoleStore.GetByNames(names)

}

func (s *RetryLayerRoleStore) PermanentDeleteAll() *model.AppError {

	return s.RoleStore.PermanentDeleteAll()

}

func (s *RetryLayerRoleStore) Save(role *model.Role) (*model.Role, *model.AppError) {

	return s.RoleStore.Save(role)

}

func (s *RetryLayerSchemeStore) CountByScope(scope string) (int64, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.CountByScope(scope)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSchemeStore) Delete(schemeId string) (*model.Scheme, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.Delete(schemeId)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSchemeStore) Get(schemeId string) (*model.Scheme, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.Get(schemeId)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.GetAllPage(scope, offset, limit)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.GetByName(schemeName)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSchemeStore) PermanentDeleteAll() error {

	tries := 0
	for {
		err := s.SchemeStore.PermanentDeleteAll()
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, error) {

	tries := 0
	for {
		result, err := s.SchemeStore.Save(scheme)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerSessionStore) AnalyticsSessionCount() (int64, *model.AppError) {

	return s.SessionStore.AnalyticsSessionCount()

}

func (s *RetryLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {

	s.SessionStore.Cleanup(expiryTime, batchSize)

}

func (s *RetryLayerSessionStore) Get(sessionIdOrToken string) (*model.Session, *model.AppError) {

	return s.SessionStore.Get(sessionIdOrToken)

}

func (s *RetryLayerSessionStore) GetSessions(userId string) ([]*model.Session, *model.AppError) {

	return s.SessionStore.GetSessions(userId)

}

func (s *RetryLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, *model.AppError) {

	return s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

}

func (s *RetryLayerSessionStore) GetSessionsWithActiveDeviceIds(userId string) ([]*model.Session, *model.AppError) {

	return s.SessionStore.GetSessionsWithActiveDeviceIds(userId)

}

func (s *RetryLayerSessionStore) PermanentDeleteSessionsByUser(teamId string) *model.AppError {

	return s.SessionStore.PermanentDeleteSessionsByUser(teamId)

}

func (s *RetryLayerSessionStore) Remove(sessionIdOrToken string) *model.AppError {

	return s.SessionStore.Remove(sessionIdOrToken)

}

func (s *RetryLayerSessionStore) RemoveAllSessions() *model.AppError {

	return s.SessionStore.RemoveAllSessions()

}

func (s *RetryLayerSessionStore) Save(session *model.Session) (*model.Session, *model.AppError) {

	return s.SessionStore.Save(session)

}

func (s *RetryLayerSessionStore) UpdateDeviceId(id string, deviceId string, expiresAt int64) (string, *model.AppError) {

	return s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)

}

func (s *RetryLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) *model.AppError {

	return s.SessionStore.UpdateExpiredNotify(sessionid, notified)

}

func (s *RetryLayerSessionStore) UpdateExpiresAt(sessionId string, time int64) *model.AppError {

	return s.SessionStore.UpdateExpiresAt(sessionId, time)

}

func (s *RetryLayerSessionStore) UpdateLastActivityAt(sessionId string, time int64) *model.AppError {

	return s.SessionStore.UpdateLastActivityAt(sessionId, time)

}

func (s *RetryLayerSessionStore) UpdateProps(session *model.Session) *model.AppError {

	return s.SessionStore.UpdateProps(session)

}

func (s *RetryLayerSessionStore) UpdateRoles(userId string, roles string) (string, *model.AppError) {

	return s.SessionStore.UpdateRoles(userId, roles)

}

func (s *RetryLayerStatusStore) Get(userId string) (*model.Status, *model.AppError) {

	return s.StatusStore.Get(userId)

}

func (s *RetryLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, *model.AppError) {

	return s.StatusStore.GetByIds(userIds)

}

func (s *RetryLayerStatusStore) GetTotalActiveUsersCount() (int64, *model.AppError) {

	return s.StatusStore.GetTotalActiveUsersCount()

}

func (s *RetryLayerStatusStore) ResetAll() *model.AppError {

	return s.StatusStore.ResetAll()

}

func (s *RetryLayerStatusStore) SaveOrUpdate(status *model.Status) *model.AppError {

	return s.StatusStore.SaveOrUpdate(status)

}

func (s *RetryLayerStatusStore) UpdateLastActivityAt(userId string, lastActivityAt int64) *model.AppError {

	return s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)

}

func (s *RetryLayerSystemStore) Get() (model.StringMap, *model.AppError) {

	return s.SystemStore.Get()

}

func (s *RetryLayerSystemStore) GetByName(name string) (*model.System, *model.AppError) {

	return s.SystemStore.GetByName(name)

}

func (s *RetryLayerSystemStore) InsertIfExists(system *model.System) (*model.System, *model.AppError) {

	return s.SystemStore.InsertIfExists(system)

}

func (s *RetryLayerSystemStore) PermanentDeleteByName(name string) (*model.System, *model.AppError) {

	return s.SystemStore.PermanentDeleteByName(name)

}

func (s *RetryLayerSystemStore) Save(system *model.System) *model.AppError {

	return s.SystemStore.Save(system)

}

func (s *RetryLayerSystemStore) SaveOrUpdate(system *model.System) *model.AppError {

	return s.SystemStore.SaveOrUpdate(system)

}

func (s *RetryLayerSystemStore) Update(system *model.System) *model.AppError {

	return s.SystemStore.Update(system)

}

func (s *RetryLayerTeamStore) AnalyticsGetTeamCountForScheme(schemeId string) (int64, *model.AppError) {

	return s.TeamStore.AnalyticsGetTeamCountForScheme(schemeId)

}

func (s *RetryLayerTeamStore) AnalyticsPrivateTeamCount() (int64, *model.AppError) {

	return s.TeamStore.AnalyticsPrivateTeamCount()

}

func (s *RetryLayerTeamStore) AnalyticsPublicTeamCount() (int64, *model.AppError) {

	return s.TeamStore.AnalyticsPublicTeamCount()

}

func (s *RetryLayerTeamStore) AnalyticsTeamCount(includeDeleted bool) (int64, *model.AppError) {

	return s.TeamStore.AnalyticsTeamCount(includeDeleted)

}

func (s *RetryLayerTeamStore) ClearAllCustomRoleAssignments() *model.AppError {

	return s.TeamStore.ClearAllCustomRoleAssignments()

}

func (s *RetryLayerTeamStore) ClearCaches() {

	s.TeamStore.ClearCaches()

}

func (s *RetryLayerTeamStore) Get(id string) (*model.Team, *model.AppError) {

	return s.TeamStore.Get(id)

}

func (s *RetryLayerTeamStore) GetActiveMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {

	return s.TeamStore.GetActiveMemberCount(teamId, restrictions)

}

func (s *RetryLayerTeamStore) GetAll() ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAll()

}

func (s *RetryLayerTeamStore) GetAllForExportAfter(limit int, afterId string) ([]*model.TeamForExport, *model.AppError) {

	return s.TeamStore.GetAllForExportAfter(limit, afterId)

}

func (s *RetryLayerTeamStore) GetAllPage(offset int, limit int) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAllPage(offset, limit)

}

func (s *RetryLayerTeamStore) GetAllPrivateTeamListing() ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAllPrivateTeamListing()

}

func (s *RetryLayerTeamStore) GetAllPrivateTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAllPrivateTeamPageListing(offset, limit)

}

func (s *RetryLayerTeamStore) GetAllPublicTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAllPublicTeamPageListing(offset, limit)

}

func (s *RetryLayerTeamStore) GetAllTeamListing() ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAllTeamListing()

}

func (s *RetryLayerTeamStore) GetAllTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetAllTeamPageListing(offset, limit)

}

func (s *RetryLayerTeamStore) GetByInviteId(inviteId string) (*model.Team, *model.AppError) {

	return s.TeamStore.GetByInviteId(inviteId)

}

func (s *RetryLayerTeamStore) GetByName(name string) (*model.Team, *model.AppError) {

	return s.TeamStore.GetByName(name)

}

func (s *RetryLayerTeamStore) GetByNames(name []string) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetByNames(name)

}

func (s *RetryLayerTeamStore) GetChannelUnreadsForAllTeams(excludeTeamId string, userId string) ([]*model.ChannelUnread, *model.AppError) {

	return s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamId, userId)

}

func (s *RetryLayerTeamStore) GetChannelUnreadsForTeam(teamId string, userId string) ([]*model.ChannelUnread, *model.AppError) {

	return s.TeamStore.GetChannelUnreadsForTeam(teamId, userId)

}

func (s *RetryLayerTeamStore) GetMember(teamId string, userId string) (*model.TeamMember, *model.AppError) {

	return s.TeamStore.GetMember(teamId, userId)

}

func (s *RetryLayerTeamStore) GetMembers(teamId string, offset int, limit int, teamMembersGetOptions *model.TeamMembersGetOptions) ([]*model.TeamMember, *model.AppError) {

	return s.TeamStore.GetMembers(teamId, offset, limit, teamMembersGetOptions)

}

func (s *RetryLayerTeamStore) GetMembersByIds(teamId string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.TeamMember, *model.AppError) {

	return s.TeamStore.GetMembersByIds(teamId, userIds, restrictions)

}

func (s *RetryLayerTeamStore) GetTeamMembersForExport(userId string) ([]*model.TeamMemberForExport, *model.AppError) {

	return s.TeamStore.GetTeamMembersForExport(userId)

}

func (s *RetryLayerTeamStore) GetTeamsByScheme(schemeId string, offset int, limit int) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetTeamsByScheme(schemeId, offset, limit)

}

func (s *RetryLayerTeamStore) GetTeamsByUserId(userId string) ([]*model.Team, *model.AppError) {

	return s.TeamStore.GetTeamsByUserId(userId)

}

func (s *RetryLayerTeamStore) GetTeamsForUser(userId string) ([]*model.TeamMember, *model.AppError) {

	return s.TeamStore.GetTeamsForUser(userId)

}

func (s *RetryLayerTeamStore) GetTeamsForUserWithPagination(userId string, page int, perPage int) ([]*model.TeamMember, *model.AppError) {

	return s.TeamStore.GetTeamsForUserWithPagination(userId, page, perPage)

}

func (s *RetryLayerTeamStore) GetTotalMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {

	return s.TeamStore.GetTotalMemberCount(teamId, restrictions)

}

func (s *RetryLayerTeamStore) GetUserTeamIds(userId string, allowFromCache bool) ([]string, *model.AppError) {

	return s.TeamStore.GetUserTeamIds(userId, allowFromCache)

}

func (s *RetryLayerTeamStore) GroupSyncedTeamCount() (int64, *model.AppError) {

	return s.TeamStore.GroupSyncedTeamCount()

}

func (s *RetryLayerTeamStore) InvalidateAllTeamIdsForUser(userId string) {

	s.TeamStore.InvalidateAllTeamIdsForUser(userId)

}

func (s *RetryLayerTeamStore) MigrateTeamMembers(fromTeamId string, fromUserId string) (map[string]string, *model.AppError) {

	return s.TeamStore.MigrateTeamMembers(fromTeamId, fromUserId)

}

func (s *RetryLayerTeamStore) PermanentDelete(teamId string) *model.AppError {

	return s.TeamStore.PermanentDelete(teamId)

}

func (s *RetryLayerTeamStore) RemoveAllMembersByTeam(teamId string) *model.AppError {

	return s.TeamStore.RemoveAllMembersByTeam(teamId)

}

func (s *RetryLayerTeamStore) RemoveAllMembersByUser(userId string) *model.AppError {

	return s.TeamStore.RemoveAllMembersByUser(userId)

}

func (s *RetryLayerTeamStore) RemoveMember(teamId string, userId string) *model.AppError {

	return s.TeamStore.RemoveMember(teamId, userId)

}

func (s *RetryLayerTeamStore) RemoveMembers(teamId string, userIds []string) *model.AppError {

	return s.TeamStore.RemoveMembers(teamId, userIds)

}

func (s *RetryLayerTeamStore) ResetAllTeamSchemes() *model.AppError {

	return s.TeamStore.ResetAllTeamSchemes()

}

func (s *RetryLayerTeamStore) Save(team *model.Team) (*model.Team, *model.AppError) {

	return s.TeamStore.Save(team)

}

func (s *RetryLayerTeamStore) SaveMember(member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, *model.AppError) {

	return s.TeamStore.SaveMember(member, maxUsersPerTeam)

}

func (s *RetryLayerTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, *model.AppError) {

	return s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)

}

func (s *RetryLayerTeamStore) SearchAll(term string) ([]*model.Team, *model.AppError) {

	return s.TeamStore.SearchAll(term)

}

func (s *RetryLayerTeamStore) SearchAllPaged(term string, page int, perPage int) ([]*model.Team, int64, *model.AppError) {

	return s.TeamStore.SearchAllPaged(term, page, perPage)

}

func (s *RetryLayerTeamStore) SearchOpen(term string) ([]*model.Team, *model.AppError) {

	return s.TeamStore.SearchOpen(term)

}

func (s *RetryLayerTeamStore) SearchPrivate(term string) ([]*model.Team, *model.AppError) {

	return s.TeamStore.SearchPrivate(term)

}

func (s *RetryLayerTeamStore) Update(team *model.Team) (*model.Team, *model.AppError) {

	return s.TeamStore.Update(team)

}

func (s *RetryLayerTeamStore) UpdateLastTeamIconUpdate(teamId string, curTime int64) *model.AppError {

	return s.TeamStore.UpdateLastTeamIconUpdate(teamId, curTime)

}

func (s *RetryLayerTeamStore) UpdateMember(member *model.TeamMember) (*model.TeamMember, *model.AppError) {

	return s.TeamStore.UpdateMember(member)

}

func (s *RetryLayerTeamStore) UpdateMembersRole(teamID string, userIDs []string) *model.AppError {

	return s.TeamStore.UpdateMembersRole(teamID, userIDs)

}

func (s *RetryLayerTeamStore) UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, *model.AppError) {

	return s.TeamStore.UpdateMultipleMembers(members)

}

func (s *RetryLayerTeamStore) UserBelongsToTeams(userId string, teamIds []string) (bool, *model.AppError) {

	return s.TeamStore.UserBelongsToTeams(userId, teamIds)

}

func (s *RetryLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {

	tries := 0
	for {
		result, err := s.TermsOfServiceStore.Get(id, allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {

	tries := 0
	for {
		result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {

	tries := 0
	for {
		result, err := s.TermsOfServiceStore.Save(termsOfService)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerTokenStore) Cleanup() {

	s.TokenStore.Cleanup()

}

func (s *RetryLayerTokenStore) Delete(token string) *model.AppError {

	return s.TokenStore.Delete(token)

}

func (s *RetryLayerTokenStore) GetByToken(token string) (*model.Token, *model.AppError) {

	return s.TokenStore.GetByToken(token)

}

func (s *RetryLayerTokenStore) RemoveAllTokensByType(tokenType string) *model.AppError {

	return s.TokenStore.RemoveAllTokensByType(tokenType)

}

func (s *RetryLayerTokenStore) Save(recovery *model.Token) *model.AppError {

	return s.TokenStore.Save(recovery)

}

func (s *RetryLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, *model.AppError) {

	return s.UserStore.AnalyticsActiveCount(time, options)

}

func (s *RetryLayerUserStore) AnalyticsGetGuestCount() (int64, *model.AppError) {

	return s.UserStore.AnalyticsGetGuestCount()

}

func (s *RetryLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, *model.AppError) {

	return s.UserStore.AnalyticsGetInactiveUsersCount()

}

func (s *RetryLayerUserStore) AnalyticsGetSystemAdminCount() (int64, *model.AppError) {

	return s.UserStore.AnalyticsGetSystemAdminCount()

}

func (s *RetryLayerUserStore) AutocompleteUsersInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) (*model.UserAutocompleteInChannel, *model.AppError) {

	return s.UserStore.AutocompleteUsersInChannel(teamId, channelId, term, options)

}

func (s *RetryLayerUserStore) ClearAllCustomRoleAssignments() *model.AppError {

	return s.UserStore.ClearAllCustomRoleAssignments()

}

func (s *RetryLayerUserStore) ClearCaches() {

	s.UserStore.ClearCaches()

}

func (s *RetryLayerUserStore) Count(options model.UserCountOptions) (int64, *model.AppError) {

	return s.UserStore.Count(options)

}

func (s *RetryLayerUserStore) DeactivateGuests() ([]string, *model.AppError) {

	return s.UserStore.DeactivateGuests()

}

func (s *RetryLayerUserStore) DemoteUserToGuest(userID string) *model.AppError {

	return s.UserStore.DemoteUserToGuest(userID)

}

func (s *RetryLayerUserStore) Get(id string) (*model.User, *model.AppError) {

	return s.UserStore.Get(id)

}

func (s *RetryLayerUserStore) GetAll() ([]*model.User, *model.AppError) {

	return s.UserStore.GetAll()

}

func (s *RetryLayerUserStore) GetAllAfter(limit int, afterId string) ([]*model.User, *model.AppError) {

	return s.UserStore.GetAllAfter(limit, afterId)

}

func (s *RetryLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, *model.AppError) {

	return s.UserStore.GetAllNotInAuthService(authServices)

}

func (s *RetryLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetAllProfiles(options)

}

func (s *RetryLayerUserStore) GetAllProfilesInChannel(channelId string, allowFromCache bool) (map[string]*model.User, *model.AppError) {

	return s.UserStore.GetAllProfilesInChannel(channelId, allowFromCache)

}

func (s *RetryLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, *model.AppError) {

	return s.UserStore.GetAllUsingAuthService(authService)

}

func (s *RetryLayerUserStore) GetAnyUnreadPostCountForChannel(userId string, channelId string) (int64, *model.AppError) {

	return s.UserStore.GetAnyUnreadPostCountForChannel(userId, channelId)

}

func (s *RetryLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, *model.AppError) {

	return s.UserStore.GetByAuth(authData, authService)

}

func (s *RetryLayerUserStore) GetByEmail(email string) (*model.User, *model.AppError) {

	return s.UserStore.GetByEmail(email)

}

func (s *RetryLayerUserStore) GetByUsername(username string) (*model.User, *model.AppError) {

	return s.UserStore.GetByUsername(username)

}

func (s *RetryLayerUserStore) GetChannelGroupUsers(channelID string) ([]*model.User, *model.AppError) {

	return s.UserStore.GetChannelGroupUsers(channelID)

}

func (s *RetryLayerUserStore) GetEtagForAllProfiles() string {

	return s.UserStore.GetEtagForAllProfiles()

}

func (s *RetryLayerUserStore) GetEtagForProfiles(teamId string) string {

	return s.UserStore.GetEtagForProfiles(teamId)

}

func (s *RetryLayerUserStore) GetEtagForProfilesNotInTeam(teamId string) string {

	return s.UserStore.GetEtagForProfilesNotInTeam(teamId)

}

func (s *RetryLayerUserStore) GetForLogin(loginId string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, *model.AppError) {

	return s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)

}

func (s *RetryLayerUserStore) GetKnownUsers(userID string) ([]string, *model.AppError) {

	return s.UserStore.GetKnownUsers(userID)

}

func (s *RetryLayerUserStore) GetNewUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetNewUsersForTeam(teamId, offset, limit, viewRestrictions)

}

func (s *RetryLayerUserStore) GetProfileByGroupChannelIdsForUser(userId string, channelIds []string) (map[string][]*model.User, *model.AppError) {

	return s.UserStore.GetProfileByGroupChannelIdsForUser(userId, channelIds)

}

func (s *RetryLayerUserStore) GetProfileByIds(userIds []string, options *UserGetByIdsOpts, allowFromCache bool) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfileByIds(userIds, options, allowFromCache)

}

func (s *RetryLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfiles(options)

}

func (s *RetryLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

}

func (s *RetryLayerUserStore) GetProfilesInChannel(channelId string, offset int, limit int) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfilesInChannel(channelId, offset, limit)

}

func (s *RetryLayerUserStore) GetProfilesInChannelByStatus(channelId string, offset int, limit int) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfilesInChannelByStatus(channelId, offset, limit)

}

func (s *RetryLayerUserStore) GetProfilesNotInChannel(teamId string, channelId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)

}

func (s *RetryLayerUserStore) GetProfilesNotInTeam(teamId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)

}

func (s *RetryLayerUserStore) GetProfilesWithoutTeam(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetProfilesWithoutTeam(options)

}

func (s *RetryLayerUserStore) GetRecentlyActiveUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	return s.UserStore.GetRecentlyActiveUsersForTeam(teamId, offset, limit, viewRestrictions)

}

func (s *RetryLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, *model.AppError) {

	return s.UserStore.GetSystemAdminProfiles()

}

func (s *RetryLayerUserStore) GetTeamGroupUsers(teamID string) ([]*model.User, *model.AppError) {

	return s.UserStore.GetTeamGroupUsers(teamID)

}

func (s *RetryLayerUserStore) GetUnreadCount(userId string) (int64, *model.AppError) {

	return s.UserStore.GetUnreadCount(userId)

}

func (s *RetryLayerUserStore) GetUnreadCountForChannel(userId string, channelId string) (int64, *model.AppError) {

	return s.UserStore.GetUnreadCountForChannel(userId, channelId)

}

func (s *RetryLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, *model.AppError) {

	return s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

}

func (s *RetryLayerUserStore) InferSystemInstallDate() (int64, *model.AppError) {

	return s.UserStore.InferSystemInstallDate()

}

func (s *RetryLayerUserStore) InvalidateProfileCacheForUser(userId string) {

	s.UserStore.InvalidateProfileCacheForUser(userId)

}

func (s *RetryLayerUserStore) InvalidateProfilesInChannelCache(channelId string) {

	s.UserStore.InvalidateProfilesInChannelCache(channelId)

}

func (s *RetryLayerUserStore) InvalidateProfilesInChannelCacheByUser(userId string) {

	s.UserStore.InvalidateProfilesInChannelCacheByUser(userId)

}

func (s *RetryLayerUserStore) PermanentDelete(userId string) *model.AppError {

	return s.UserStore.PermanentDelete(userId)

}

func (s *RetryLayerUserStore) PromoteGuestToUser(userID string) *model.AppError {

	return s.UserStore.PromoteGuestToUser(userID)

}

func (s *RetryLayerUserStore) ResetLastPictureUpdate(userId string) *model.AppError {

	return s.UserStore.ResetLastPictureUpdate(userId)

}

func (s *RetryLayerUserStore) Save(user *model.User) (*model.User, *model.AppError) {

	return s.UserStore.Save(user)

}

func (s *RetryLayerUserStore) Search(teamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.Search(teamId, term, options)

}

func (s *RetryLayerUserStore) SearchInChannel(channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.SearchInChannel(channelId, term, options)

}

func (s *RetryLayerUserStore) SearchInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.SearchInGroup(groupID, term, options)

}

func (s *RetryLayerUserStore) SearchNotInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.SearchNotInChannel(teamId, channelId, term, options)

}

func (s *RetryLayerUserStore) SearchNotInTeam(notInTeamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.SearchNotInTeam(notInTeamId, term, options)

}

func (s *RetryLayerUserStore) SearchWithoutTeam(term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	return s.UserStore.SearchWithoutTeam(term, options)

}

func (s *RetryLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, *model.AppError) {

	return s.UserStore.Update(user, allowRoleUpdate)

}

func (s *RetryLayerUserStore) UpdateAuthData(userId string, service string, authData *string, email string, resetMfa bool) (string, *model.AppError) {

	return s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)

}

func (s *RetryLayerUserStore) UpdateFailedPasswordAttempts(userId string, attempts int) *model.AppError {

	return s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)

}

func (s *RetryLayerUserStore) UpdateLastPictureUpdate(userId string) *model.AppError {

	return s.UserStore.UpdateLastPictureUpdate(userId)

}

func (s *RetryLayerUserStore) UpdateMfaActive(userId string, active bool) *model.AppError {

	return s.UserStore.UpdateMfaActive(userId, active)

}

func (s *RetryLayerUserStore) UpdateMfaSecret(userId string, secret string) *model.AppError {

	return s.UserStore.UpdateMfaSecret(userId, secret)

}

func (s *RetryLayerUserStore) UpdatePassword(userId string, newPassword string) *model.AppError {

	return s.UserStore.UpdatePassword(userId, newPassword)

}

func (s *RetryLayerUserStore) UpdateUpdateAt(userId string) (int64, *model.AppError) {

	return s.UserStore.UpdateUpdateAt(userId)

}

func (s *RetryLayerUserStore) VerifyEmail(userId string, email string) (string, *model.AppError) {

	return s.UserStore.VerifyEmail(userId, email)

}

func (s *RetryLayerUserAccessTokenStore) Delete(tokenId string) *model.AppError {

	return s.UserAccessTokenStore.Delete(tokenId)

}

func (s *RetryLayerUserAccessTokenStore) DeleteAllForUser(userId string) *model.AppError {

	return s.UserAccessTokenStore.DeleteAllForUser(userId)

}

func (s *RetryLayerUserAccessTokenStore) Get(tokenId string) (*model.UserAccessToken, *model.AppError) {

	return s.UserAccessTokenStore.Get(tokenId)

}

func (s *RetryLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, *model.AppError) {

	return s.UserAccessTokenStore.GetAll(offset, limit)

}

func (s *RetryLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, *model.AppError) {

	return s.UserAccessTokenStore.GetByToken(tokenString)

}

func (s *RetryLayerUserAccessTokenStore) GetByUser(userId string, page int, perPage int) ([]*model.UserAccessToken, *model.AppError) {

	return s.UserAccessTokenStore.GetByUser(userId, page, perPage)

}

func (s *RetryLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, *model.AppError) {

	return s.UserAccessTokenStore.Save(token)

}

func (s *RetryLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, *model.AppError) {

	return s.UserAccessTokenStore.Search(term)

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenDisable(tokenId string) *model.AppError {

	return s.UserAccessTokenStore.UpdateTokenDisable(tokenId)

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenEnable(tokenId string) *model.AppError {

	return s.UserAccessTokenStore.UpdateTokenEnable(tokenId)

}

func (s *RetryLayerUserTermsOfServiceStore) Delete(userId string, termsOfServiceId string) error {

	tries := 0
	for {
		err := s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)
		if err == nil {
			return err
		}
		if !isRepeatableError(err) {
			return err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return err
		}
	}

}

func (s *RetryLayerUserTermsOfServiceStore) GetByUser(userId string) (*model.UserTermsOfService, error) {

	tries := 0
	for {
		result, err := s.UserTermsOfServiceStore.GetByUser(userId)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, error) {

	tries := 0
	for {
		result, err := s.UserTermsOfServiceStore.Save(userTermsOfService)
		if err == nil {
			return result, err
		}
		if !isRepeatableError(err) {
			return result, err
		}
		tries++
		if tries > 3 {
			err = errors.Wrap(err, "giving up after 3 consecutive repeatable transaction failures")
			return result, err
		}
	}

}

func (s *RetryLayerWebhookStore) AnalyticsIncomingCount(teamId string) (int64, *model.AppError) {

	return s.WebhookStore.AnalyticsIncomingCount(teamId)

}

func (s *RetryLayerWebhookStore) AnalyticsOutgoingCount(teamId string) (int64, *model.AppError) {

	return s.WebhookStore.AnalyticsOutgoingCount(teamId)

}

func (s *RetryLayerWebhookStore) ClearCaches() {

	s.WebhookStore.ClearCaches()

}

func (s *RetryLayerWebhookStore) DeleteIncoming(webhookId string, time int64) *model.AppError {

	return s.WebhookStore.DeleteIncoming(webhookId, time)

}

func (s *RetryLayerWebhookStore) DeleteOutgoing(webhookId string, time int64) *model.AppError {

	return s.WebhookStore.DeleteOutgoing(webhookId, time)

}

func (s *RetryLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.GetIncoming(id, allowFromCache)

}

func (s *RetryLayerWebhookStore) GetIncomingByChannel(channelId string) ([]*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.GetIncomingByChannel(channelId)

}

func (s *RetryLayerWebhookStore) GetIncomingByTeam(teamId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.GetIncomingByTeam(teamId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetIncomingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.GetIncomingByTeamByUser(teamId, userId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.GetIncomingList(offset, limit)

}

func (s *RetryLayerWebhookStore) GetIncomingListByUser(userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.GetIncomingListByUser(userId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoing(id)

}

func (s *RetryLayerWebhookStore) GetOutgoingByChannel(channelId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoingByChannel(channelId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetOutgoingByChannelByUser(channelId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoingByChannelByUser(channelId, userId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetOutgoingByTeam(teamId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoingByTeam(teamId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetOutgoingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoingByTeamByUser(teamId, userId, offset, limit)

}

func (s *RetryLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoingList(offset, limit)

}

func (s *RetryLayerWebhookStore) GetOutgoingListByUser(userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)

}

func (s *RetryLayerWebhookStore) InvalidateWebhookCache(webhook string) {

	s.WebhookStore.InvalidateWebhookCache(webhook)

}

func (s *RetryLayerWebhookStore) PermanentDeleteIncomingByChannel(channelId string) *model.AppError {

	return s.WebhookStore.PermanentDeleteIncomingByChannel(channelId)

}

func (s *RetryLayerWebhookStore) PermanentDeleteIncomingByUser(userId string) *model.AppError {

	return s.WebhookStore.PermanentDeleteIncomingByUser(userId)

}

func (s *RetryLayerWebhookStore) PermanentDeleteOutgoingByChannel(channelId string) *model.AppError {

	return s.WebhookStore.PermanentDeleteOutgoingByChannel(channelId)

}

func (s *RetryLayerWebhookStore) PermanentDeleteOutgoingByUser(userId string) *model.AppError {

	return s.WebhookStore.PermanentDeleteOutgoingByUser(userId)

}

func (s *RetryLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.SaveIncoming(webhook)

}

func (s *RetryLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.SaveOutgoing(webhook)

}

func (s *RetryLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {

	return s.WebhookStore.UpdateIncoming(webhook)

}

func (s *RetryLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {

	return s.WebhookStore.UpdateOutgoing(hook)

}

func (s *RetryLayer) Close() {
	s.Store.Close()
}

func (s *RetryLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *RetryLayer) GetCurrentSchemaVersion() string {
	return s.Store.GetCurrentSchemaVersion()
}

func (s *RetryLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *RetryLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *RetryLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *RetryLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *RetryLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *RetryLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func (s *RetryLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func NewRetryLayer(childStore Store) *RetryLayer {
	newStore := RetryLayer{
		Store: childStore,
	}

	newStore.AuditStore = &RetryLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.BotStore = &RetryLayerBotStore{BotStore: childStore.Bot(), Root: &newStore}
	newStore.ChannelStore = &RetryLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.ChannelMemberHistoryStore = &RetryLayerChannelMemberHistoryStore{ChannelMemberHistoryStore: childStore.ChannelMemberHistory(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &RetryLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &RetryLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.CommandWebhookStore = &RetryLayerCommandWebhookStore{CommandWebhookStore: childStore.CommandWebhook(), Root: &newStore}
	newStore.ComplianceStore = &RetryLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.EmojiStore = &RetryLayerEmojiStore{EmojiStore: childStore.Emoji(), Root: &newStore}
	newStore.FileInfoStore = &RetryLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.GroupStore = &RetryLayerGroupStore{GroupStore: childStore.Group(), Root: &newStore}
	newStore.JobStore = &RetryLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &RetryLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &RetryLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.OAuthStore = &RetryLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.PluginStore = &RetryLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PostStore = &RetryLayerPostStore{PostStore: childStore.Post(), Root: &newStore}
	newStore.PreferenceStore = &RetryLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ReactionStore = &RetryLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RoleStore = &RetryLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SchemeStore = &RetryLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &RetryLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.StatusStore = &RetryLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &RetryLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TeamStore = &RetryLayerTeamStore{TeamStore: childStore.Team(), Root: &newStore}
	newStore.TermsOfServiceStore = &RetryLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &RetryLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UserStore = &RetryLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &RetryLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &RetryLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &RetryLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}

// Copyright (c) 2017-present Mattermost, Inc. All Rights Reserved.
// See License.txt for license information.

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"reflect"
	"text/template"

	"github.com/mattermost/mattermost-server/web"
)

const tagName = "param"

type TemplateData struct {
	ParamName string
	FieldName string
}

const boolTemplate = `if val, err := strconv.ParseBool(query.Get("{{.ParamName}}")); err == nil {
	params.{{.FieldName}} = val
}`

const stringTemplate = `if val, ok := props["{{.ParamName}}"]; ok {
	params.{{.FieldName}} = val
}`

const goFile = `// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See License.txt for license information.

// Code generated by web/params_gen/params_gen.go; DO NOT EDIT.

package web

import (
"net/http"
"strconv"

"github.com/gorilla/mux"
)

func ParamsFromRequest(r *http.Request) *Params {
params := &Params{}

props := mux.Vars(r)
query := r.URL.Query()

{{ range $val := . }}
{{ $val }}
  {{ end }}

return params
}
`

func main() {
	code, err := getCode()
	if err != nil {
		log.Fatal(err)
	}

	outputFile, err := os.Create("./params_from_request.go")
	if err != nil {
		panic(err)
	}
	defer outputFile.Close()

	fmt.Fprintf(outputFile, string(code))
}

func formatCode(code []byte) ([]byte, error) {
	fmtCode, err := format.Source(code)
	if err != nil {
		return nil, err
	}
	return fmtCode, nil
}

func getCode() ([]byte, error) {
	var buff bytes.Buffer
	t := reflect.TypeOf(web.Params{})
	var functionStrings = make([]string, t.NumField())

	gofileTmpl, err := template.New("master").Parse(goFile)
	if err != nil {
		return nil, err
	}

	boolTmpl, err := template.New("bool").Parse(boolTemplate)
	if err != nil {
		return nil, err
	}

	stringTmpl, err := template.New("string").Parse(stringTemplate)
	if err != nil {
		return nil, err
	}

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get(tagName)

		if len(tag) == 0 {
			continue
		}

		var template *template.Template
		switch field.Type.Name() {
		case "string":
			template = stringTmpl
		case "bool":
			template = boolTmpl
		default:
			continue
		}

		td := TemplateData{FieldName: field.Name, ParamName: tag}

		if err = template.Execute(&buff, td); err != nil {
			return nil, err
		}

		functionStrings = append(functionStrings, buff.String())

		buff.Reset()
	}

	if err = gofileTmpl.Execute(&buff, functionStrings); err != nil {
		return nil, err
	}

	fmtCode, err := formatCode(buff.Bytes())
	if err != nil {
		return nil, err
	}

	return fmtCode, nil
}
